\documentclass[USenglish]{article}
%Second Revision

% Some common notation, to help us be consistent
% \bsk = wavenumber
% \ell = coordinate index
% w_\ell = coordinate weight
% s_k = smoothness weight
% r = decay rate of wavenumbers
% \bslambda = weights used to define 

\usepackage[utf8]{inputenc}%(only for the pdftex engine)
%\RequirePackage[no-math]{fontspec}[2017/03/31]%(only for the luatex or the xetex engine)
\usepackage[small]{dgruyter}
\usepackage{microtype}
\usepackage{amsmath,amssymb}
\usepackage{subcaption}
\usepackage{bbm}
\input{macros}

%\usepackage[notref,notcite]{showkeys}

%% Beginning of author included packages and defined macros
\usepackage{color,mathtools,bbm,xspace,natbib}
\usepackage{algpseudocode}
\usepackage{algorithm, algorithmicx}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\DHKMALGnewcommand\DHKMALGorithmicparam{\textbf{Parameters:}}
\DHKMALGnewcommand\PARAM{\item[\DHKMALGorithmicparam]}
\DHKMALGnewcommand\DHKMALGorithmicinput{\textbf{Input:}}
\DHKMALGnewcommand\INPUT{\item[\DHKMALGorithmicinput]}
%\DHKMALGnewcommand\STATE{\item}
\DHKMALGnewcommand\RETURN{\State \textbf{Return }}

\theoremstyle{dgthm}
\newtheorem{theorem}{Theorem}
\theoremstyle{dgthm}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{dgthm}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{dgthm}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{dgdef}
\newtheorem{remark}{Remark}
\theoremstyle{definition}
\newtheorem{exmp}{Example}

\DeclareMathOperator{\DHKMSOL}{SOL}
\DeclareMathOperator{\DHKMAPP}{APP}
\DeclareMathOperator{\DHKMALG}{ALG}
\DeclareMathOperator{\DHKMERR}{ERR}
\DeclareMathOperator{\DHKMcard}{card}
\newcommand{\DHKMdataN}{\bigl(\hf(\bsk_i)\bigr)_{i=1}^n}
\newcommand{\DHKMdataNj}{\bigl(\hf(\bsk_i)\bigr)_{i=1}^{n_j}}
\newcommand{\DHKMdataNjd}{\bigl(\hf(\bsk_i)\bigr)_{i=1}^{n_{j^\dagger}}}
\newcommand{\DHKMERRN}{\DHKMERR\bigl(\DHKMdataN,n\bigr)}
\newcommand{\DHKMERRNj}{\DHKMERR\bigl(\DHKMdataNj,n_j\bigr)}
\newcommand{\DHKMERRNjd}{\DHKMERR\bigl(\DHKMdataNjd,n_{j^\dagger}\bigr)}
\DeclareMathOperator{\DHKMCOST}{COST}
\DeclareMathOperator{\COMP}{COMP}
\newcommand{\hf}{\widehat{f}}
\newcommand{\hg}{\widehat{g}}
\newcommand{\tu}{\Tilde{u}}
\newcommand{\tv}{\Tilde{v}}
\newcommand{\tcalJ}{\widetilde{\calJ}}
\newcommand{\tcalK}{\widetilde{\calK}}
\newcommand{\tlambda}{\Tilde{\lambda}}
\newcommand{\tbbK}{\widetilde{\bbK}}
\newcommand{\lo}{\textup{lo}}
\newcommand{\up}{\textup{up}}
\newcommand{\inc}{\textup{in}}
\newcommand{\out}{\textup{out}}
\newcommand{\E}{\textup{e}}
\def\abs#1{\ensuremath{\left \lvert #1 \right \rvert}}
\newcommand{\normabs}[1]{\ensuremath{\lvert #1 \rvert}}
\newcommand{\bigabs}[1]{\ensuremath{\bigl \lvert #1 \bigr \rvert}}
\newcommand{\Bigabs}[1]{\ensuremath{\Bigl \lvert #1 \Bigr \rvert}}
\newcommand{\biggabs}[1]{\ensuremath{\biggl \lvert #1 \biggr \rvert}}
\newcommand{\Biggabs}[1]{\ensuremath{\Biggl \lvert #1 \Biggr \rvert}}
\newcommand{\norm}[2][{}]{\ensuremath{\left \lVert #2 \right \rVert}_{#1}}
\newcommand{\normnorm}[2][{}]{\ensuremath{\lVert #2 \rVert}_{#1}}
\newcommand{\bignorm}[2][{}]{\ensuremath{\bigl \lVert #2 \bigr \rVert}_{#1}}
\newcommand{\Bignorm}[2][{}]{\ensuremath{\Bigl \lVert #2 \Bigr \rVert}_{#1}}
\newcommand{\biggnorm}[2][{}]{\ensuremath{\biggl \lVert #2 \biggr \rVert}_{#1}}
\newcommand{\ip}[3][{}]{\ensuremath{\left \langle #2, #3 \right \rangle_{#1}}}
\newcommand{\FredNote}[1]{{\color{blue}Fred: #1}}
\newcommand{\YuhanNote}[1]{{\color{magenta}Yuhan: #1}}
\newcommand{\PeterNote}[1]{{\color{orange}Peter: #1}}
\newcommand{\SimonNote}[1]{{\color{purple}Simon: #1}}
\newcommand{\DHKMchange}[1]{{\color{red}{#1}}}

\newcommand{\tLambda}{\widetilde{\Lambda}}
\newcommand{\bcalK}{\bar{\calK}}
\newcommand{\fapp}{f_{\text{app}}}
%\newcommand{\HickernellFJ}{Hickernell}

\allowdisplaybreaks

%% End of author included packages and defined macros

\begin{document}

  %\articletype{...}

  \author[1]{Yuhan Ding}
  \author*[2]{Fred J. Hickernell}
  \author[3]{Peter Kritzer} 
  \author[4]{Simon Mak}
  \runningauthor{Y. Ding, F. J. Hickernell, P. Kritzer, and S. Mak}
  \affil[1]{Department of Applied Mathematics, Illinois Institute of Technology, RE 220, 10 W.\ 32${}\text{nd}$ Street, Chicago, IL 60616 USA}
  \affil[2]{Department of Applied Mathematics, Illinois Institute of Technology, RE 220, 10 W.\ 32${}\text{nd}$ Street, Chicago, IL 60616 USA}
  \affil[3]{Johann Radon Institute for Computational and Applied Mathematics (RICAM), 
  Austrian Academy of Sciences, Altenbergerstr. 69, 4040 Linz, Austria}
  \affil[4]{Department of Statistical Science, Duke University, Durham, NC 27708-0251 USA}
  \title{Adaptive Approximation for Multivariate Linear Problems with Inputs Lying in a Cone}
  \runningtitle{Adaptive Approximation}
  %\subtitle{...}
  \abstract{We study adaptive approximation algorithms for general multivariate linear 
  problems where the sets of input functions are non-convex cones. While it is known that adaptive algorithms perform 
  essentially no better than non-adaptive algorithms for convex and symmetric input sets, the 
  situation may be different for non-convex sets. The setting 
  considered here is function approximation based on series expansions. Given 
  an error tolerance, we use series coefficients of the input to construct an 
  approximate solution such that the error does not exceed this tolerance. We study the situation where we can bound the norm of the input based on a pilot sample, and the situation where we keep track of the decay rate of the series coefficients of the input. Moreover, 
  we consider situations where it makes sense to infer coordinate and smoothness importance. Besides performing an error analysis, we also derive upper bounds on the information cost of our algorithms and lower bounds on the computational complexity 
  of our problems, and we identify conditions under which we can avoid a curse of 
  dimensionality.}
  %\keywords{...}
  %\classification[PACS]{...}
  %\communicated{...}
  %\dedication{...}
  %\received{...}
  %\accepted{...}
  %\journalname{...}
  %\journalyear{...}
  %\journalvolume{..}
  %\journalissue{..}
  \startpage{1}
  \aop
  %\DOI{...}

\maketitle



%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In many situations, adaptive algorithms can be rigorously shown to perform \emph{essentially no better} than non-adaptive algorithms.  Yet, in practice adaptive algorithms are appreciated because they relieve the user from stipulating the computational effort required to achieve the desired accuracy.  The key to resolving this seeming contradiction is to construct a theory based on assumptions that favor adaptive algorithms. We do that here.

Adaptive algorithms infer the necessary computational effort based on the function data sampled.  Adaptive algorithms may perform better than non-adaptive algorithms if the set of input functions is \emph{non-convex} or \emph{non-symmetric}. Here we focus on the former situation and construct adaptive algorithms for general multivariate linear problems where the input functions lie in non-convex cones, $\calC$. By a cone, we mean a set of functions where constant multiples of every function in the set also lie in the set. The precise definitions of the cones that we study are given below.

Our algorithms use a finite number of series coefficients of the input function to construct an approximate solution that satisfies an absolute error tolerance.  We show our algorithms to be essentially optimal.  We derive conditions under which the problem is tractable, i.e., the information cost of constructing the approximate solution does not increase exponentially with the dimension of the input function domain.  In the remainder of this section we outline the general idea of this chapter. 



We study the approximation of a linear solution operator $\DHKMSOL:\calF \to \calG$, which maps $f\in\calF$ to some $g\in\calG$, where we assume that $\calF$ and $\calG$ are Banach spaces with norms $\norm[\calF]{\cdot}$ and $\norm[\calG]{\cdot}$, respectively. Our goal is to define a suitable set of input functions $\calC$, and an algorithm $\DHKMALG(\cdot,\cdot):\calC \times (0,\infty) \to \calG$ that satisfies the error criterion:
\begin{equation} \label{DHKM:err_crit}
    \norm[\calG]{\DHKMSOL(f) - \DHKMALG(f,\varepsilon)} \le \varepsilon \qquad \forall \varepsilon > 0, \ f \in \calC,
\end{equation}
where  $\varepsilon$ denotes the error tolerance. Such an algorithm will  contain a rule for choosing the number of series coefficients required, $n(f,\varepsilon)$, which depends on $f$ and $\varepsilon$.  The objectives of this chapter are to 
\begin{itemize}
    \item construct such a rule, 
    \item choose a set $\calC$ of input functions for which the rule is valid,  
    \item characterize the information cost of $\DHKMALG$, 
    \item determine whether $\DHKMALG$ has optimal information cost, and 
    \item understand the dependence of this cost on the number of input variables, $d$, as well as the error tolerance, $\varepsilon$.
\end{itemize}

We assume in this chapter that the functions $f\in\calF$ can be represented in terms of a basis representation as $f = \sum_{\bsk \in \mathbb{K}} \hf(\bsk) u_{\bsk}$, and we allow algorithms $\DHKMALG (f,\varepsilon)$ to use $n(f,\varepsilon)$ coefficients $\hf (\bsk)$ of this representation. That is, 
we study algorithms that have an output of the form 
\begin{equation*} %\label{DHKM:algform}
  \DHKMALG(f,\varepsilon) = \sum_{i=1}^{n(f,\varepsilon)}\hf(\bsk_i) v_{\bsk_i} \qquad \forall f \in \calF, \ n(f,\varepsilon) \in \N,
\end{equation*}
where an oracle provides $\hf(\bsk_1),\ldots,\hf (\bsk_{n(f,\varepsilon)})$ 
with $n(f,\varepsilon)$ being chosen based on a stopping rule. 
We assume that it is possible to sample the series coefficients of the input function.  This is a more restrictive assumption than being able to sample any linear functional, but it is different than only being able to sample function values.  An important future problem is to extend the theory in this chapter to the case where the only function data available are function values.

The information cost of $\DHKMALG(f,\varepsilon)$ is denoted $\DHKMCOST(\DHKMALG,f,\varepsilon)$ and defined as the number of function data---in our situation, series coefficients---required by $\DHKMALG(f,\varepsilon)$, i.e., $\DHKMCOST(\DHKMALG,f,\varepsilon) = n(f,\varepsilon)$.  For adaptive algorithms this cost varies with the input function $f$.  We call an algorithm \emph{non-adaptive} if $n(f,\varepsilon)=n(\varepsilon)$, independently of the particular choice of $f\in\calC$, and also the sequence $\bsk_1, \bsk_2, \ldots$ is independent of the choice of $f\in\calC$. 

In the following, let $\calB_{R} : = \{ f \in \calF : \norm[\calF]{f} \le R \}$ denote the ball of radius $R$ in the space of input functions.
We now define the information cost of the algorithm in general, recognizing that it will tend to depend on $\norm[\calF]{f}$:
\begin{equation*}
    \DHKMCOST(\DHKMALG, \calC, \varepsilon,R) : = \max_{f \in \calC \cap \calB_{R}} \DHKMCOST(\DHKMALG,f,\varepsilon).
\end{equation*}
Note that while the cost depends on $\norm[\calF]{f}$, $\DHKMALG(f,\varepsilon)$ has no knowledge of $f$ beyond the fact that it lies in $\calC$.  It is common for $\DHKMCOST(\DHKMALG, \calC, \varepsilon,R)$ to be $\calO(\varepsilon^{-p})$, or perhaps asymptotically $c\log(1 + \varepsilon^{-1})$.

\medskip

A crucial concept is the set of all possible algorithms that may be constructed using series coefficients and that \emph{satisfy error criterion \eqref{DHKM:err_crit}}. We denote this set by $\calA(\calC)$. 
Furthermore, we define the \emph{computational complexity} of a problem as the information cost of the best algorithm:
\begin{equation*}
    \COMP(\calC, \varepsilon,R) := \min_{\DHKMALG \in \calA(\calC)} \DHKMCOST(\DHKMALG, \calC, \varepsilon,R) .
\end{equation*}
These definitions follow the information-based complexity literature \citep{TraWer98, TraWasWoz88}.
We define an algorithm to be \emph{essentially optimal} if there exist some fixed positive $\omega$, $\varepsilon_{\max}$, and $R_{\min}$ for which
\begin{multline} \label{DHKM:EssentialOpt}
    \DHKMCOST(\DHKMALG, \calC, \varepsilon,R) \le \COMP(\calC, \omega \varepsilon,R) \\ \forall \, \varepsilon \in (0, \varepsilon_{\max}], \ R \in [R_{\min}, \infty).
\end{multline}
If the complexity of the problem is $\calO(\varepsilon^{-p})$, the cost of an essentially optimal algorithm is also $\calO(\varepsilon^{-p})$. If the complexity of the problem is asymptotically $c \log(1 + \varepsilon^{-1})$, then  the cost of an essentially optimal algorithm is also asymptotically $c \log(1 + \varepsilon^{-1})$. 
We will show that our adaptive algorithms presented in Sections \ref{DHKM:pilot_sec} and \ref{DHKM:tracking_sec}  are essentially optimal.

We demonstrate below that non-adaptive algorithms are optimal when the set of inputs is chosen to be $\calC = \calB_R$. However, typically one cannot bound the norm of the input function a priori, so non-adaptive algorithms may be impractical. 
This will lead to \emph{adaptive} algorithms $\DHKMALG$ satisfying error criterion \eqref{DHKM:err_crit}.  For such algorithms, the set of allowable input functions, $\calC$, will be a \emph{cone}, not a ball. We study different variants of cones in different sections of this chapter. 

The first definition of a cone is given in \eqref{DHKM:pilot_cone}, 
where the idea is that the cone consists of $f\in\calF$ such that 
$$
  \norm[\calF]{f}\le h (\hf(\bsk_1),\ldots,\hf (\bsk_{n_1}))
$$
for a suitably chosen homogeneous function $h:\bbR^{n_1}\to [0,\infty)$. This means that the norm of $f$ can be bounded well in terms of 
a \emph{pilot sample} of size $n_1\in\bbN$. See \eqref{DHKM:pilot_cone} for the precise definition. In Section \ref{DHKM:SecAdapAlgTrackDecay}, we will modify the definition of cones such that we can keep track of the decay rate of the series coefficients of the input function (see \eqref{DHKM:TrackConeDef}), 
and in Section \ref{DHKM:smoothimportance_sec} we allow a situation 
where we infer coordinate and smoothness importance from some initial data, thus making the definition of the cone more practical (see  
\eqref{DHKM:pilot_cone2}).

Note that algorithms satisfying error criterion \eqref{DHKM:err_crit} cannot exist for $\calC = \calF$. Any algorithm must require a finite sample size, even if it is huge.  Then, there must exist some $f \in \calF$ that looks exactly like the zero function to the algorithm but for which $\norm[\calG]{\DHKMSOL(f)}$ is arbitrarily large.  Thus, algorithms satisfying the error criterion  exist only for some strict subset of $\calF$, such as a ball or a cone.  Identifying that subset is both an art and a science.

The rest of this chapter is structured as follows. In the next section, we formulate our problem more formally, including the precise definition of the input space, $\calF$, in terms of a sequence of weights, $\bslambda$, which reflect the assumed smoothness of the input functions.  We point out some results for non-adaptive algorithms with inputs from balls. Furthermore, we illustrate our theory by 
a particular example, and mention some definitions regarding \emph{tractability}. 

In Section \ref{DHKM:pilot_sec}, we define a cone of input functions, $\calC$, in \eqref{DHKM:pilot_cone} whose norms can be bounded above in terms of the series coefficients obtained from a pilot sample.  Adaptive Algorithm \ref{DHKM:PilotConeAlg} is shown to be optimal for this $\calC$.  We also identify necessary and sufficient conditions for tractability.

Section \ref{DHKM:tracking_sec} considers the situation where function data is relatively inexpensive, and we track the decay rate of the series coefficients.  Adaptive Algorithm \ref{DHKM:TrackConeAlg} is shown to be optimal in this situation.

Section \ref{DHKM:smoothimportance_sec} considers the case where the most suitable weights $\bslambda$, which are used to define the input space, $\calF$, are not known a priori and are instead themselves inferred from function data.  Adaptive Algorithm \ref{DHKM:InfPilotConeAlg} combines this inference step with Algorithm \ref{DHKM:PilotConeAlg} to construct an approximation that satisfies the error criterion.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Formal Setting}\label{DHKM:secprobdef}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Problem Formulation}

Now, we define our problem more formally.  The solution operator $\DHKMSOL$ maps the input function to an output, $\DHKMSOL:\calF \to \calG$.  The Banach spaces of inputs and outputs are defined by series expansions:
\begin{gather*}
    \calF := \left \{f = \sum_{\bsk \in \mathbb{K}} \hf(\bsk) u_{\bsk} : \norm[\calF]{f} : = \norm[\rho]{\left( \frac{\hf(\bsk)}{\lambda_{\bsk}} \right)_{\bsk \in \mathbb{K}}} < \infty \right\}, \quad\mbox{with}\quad 1 \le \rho \le \infty, 
\end{gather*}
and
\begin{gather*}
    \calG := \left \{g = \sum_{\bsk \in \mathbb{K}} \hg(\bsk) v_{\bsk} : \norm[\calG]{g} : = \norm[\tau]{\bigl(  \hg(\bsk)  \bigr)_{\bsk \in \mathbb{K}}} < \infty \right\}, \quad\mbox{with}\quad 1 \le \tau \le \rho.
\end{gather*}

Here, $\{u_{\bsk}\}_{\bsk \in \mathbb{K}}$ is a basis for the input Banach space $\calF$, $\{v_{\bsk}\}_{\bsk \in \mathbb{K}}$ is a basis for the output Banach space $\calG$, and $\mathbb{K}$ is a countable index set.  These bases are defined to match the solution operator:
\begin{equation} \label{DHKM:basis_relate}
    \DHKMSOL(u_{\bsk}) = v_{\bsk} \qquad \forall \bsk \in \mathbb{K}.
\end{equation}

The $\lambda_{\bsk}$ represent the importance of the series coefficients of the input function.  The larger $\lambda_{\bsk}$ is, the more important $\hf(\bsk)$ is.  The $\lambda_{\bsk}$ are assumed to have a known order:
\begin{equation} \label{DHKM:lambda_order}
    \lambda_{\bsk_1} \ge \lambda_{\bsk_2} \ge \cdots >0,
\end{equation}
implies an ordering of the wavenumbers, $\bsk$. We also assume that all $\lambda_{\bsk}$ are  positive to avoid the trivial case where $\DHKMSOL(f)$ can be expressed exactly as a finite sum for all $f \in \calF$.  We denote the sequence of weights  $\bigl(\lambda_{\bsk_i}\bigr)_{i=1}^\infty$ by $\bslambda$.

Although this problem formulation is quite general in some aspects, condition \eqref{DHKM:basis_relate} is somewhat restrictive.  In principle, the choice of basis can be made via the singular value decomposition, but in practice, if the norms of $\calF$ and $\calG$ are specified without reference to their respective bases, it may be difficult to identify bases satisfying \eqref{DHKM:basis_relate}.

Some of the results on balls in this chapter can be found elsewhere, e.g., \cite[Section 11.11]{Pie78a}  and \cite[Chap.\ VI, Sect.\ 2]{Pin85a}, but we provide proofs for the sake of completeness. To facilitate our derivations below, we establish the following lemma via H\"older's inequality:

\begin{lemma} \label{DHKM:Key_Lem}
Let $\calK$ be some proper or improper subset of the index set $\bbK$. Moreover, let $\rho'$ be defined by the relation
\begin{equation*}
    \frac 1\rho + \frac 1 {\rho'} = \frac 1 \tau, \qquad \text{i.e., } \rho' := \frac{\rho \tau}{\rho - \tau},
\end{equation*}
so $\tau \le \rho' \le \infty$.  Let $\Lambda :=  \bignorm[\rho']{\bigl(  \lambda_{\bsk}  \bigr)_{\bsk \in \calK}}$ be the norm of a subset of the weights.  Then the following are true for $f = \sum_{\bsk \in \calK} \hf(\bsk) u_{\bsk}$:
\begin{equation}
\label{DHKM:SOL_ineq}
    \norm[\calG]{\DHKMSOL(f)} = \norm[\tau]{\bigl(\hf(\bsk) \bigr)_{\bsk \in \calK}} \le \norm[\calF]{f} \, \Lambda,
    \end{equation}
    \begin{multline}
    \label{DHKM:SOL_tight_ineq}
    \bigabs{\hf(\bsk)} = \begin{cases}
    \displaystyle 
    \frac{R \lambda_{\bsk}^{\rho'/\rho + 1}}{\Lambda^{\rho'/\rho}}, & \forall \bsk \in \calK, \quad  \text{if}\ \rho'<\infty, \\
    R \Lambda \delta_{\bsk,\bsk^*}, & \forall \bsk \in \calK, \ \bsk^* \in \calK \text{ satisfies } \lambda_{\bsk^*} = \Lambda, \quad\text{if}\ \rho' = \infty,
    \end{cases}
   \\ 
    \implies  \ \ \norm[\calF]{f} = R \ \mbox{and} \ \norm[\calG]{\DHKMSOL(f)} = R \Lambda.
    \end{multline}
Equality \eqref{DHKM:SOL_tight_ineq} illustrates how inequality \eqref{DHKM:SOL_ineq} may be made tight.
\end{lemma}
\begin{proof}
We give the proof for $\rho' < \infty$.  The proof for $\rho' = \infty$ follows similarly. 
The proof of inequality \eqref{DHKM:SOL_ineq} proceeds by applying H\"older's inequality:  
\begin{align}
    \label{DHKM:SOL_A}
    \norm[\calG]{\DHKMSOL(f)}  
    & = \biggnorm[\calG]{\sum_{\bsk \in \calK} \hf(\bsk) v_{\bsk}} = \norm[\tau]{\bigl(  \hf(\bsk)  \bigr)_{\bsk \in \calK}}  = \left [\sum_{\bsk \in \calK}  \left\lvert\frac{\hf(\bsk)}{\lambda_{\bsk}} \right\rvert^{\tau} \lambda_{\bsk}^{\tau} \right]^{1/\tau} \\
    \nonumber
    & \le \biggnorm[\rho]{\biggl(  \frac{\hf(\bsk)}{\lambda_{\bsk}}  \biggr)_{\bsk \in \calK}} \, \bignorm[\rho']{\bigl(  \lambda_{\bsk}  \bigr)_{\bsk \in \calK}} = \norm[\calF]{f} \, \Lambda \qquad \text{since }\frac 1\rho + \frac 1 {\rho'} = \frac 1 \tau.
\end{align}
Substituting the formula for $\bigabs{\hf(\bsk)}$ in \eqref{DHKM:SOL_tight_ineq} into equation \eqref{DHKM:SOL_A} and applying the relationship between $\rho$, $\rho'$, and $\tau$ yields
\begin{equation*}
       \norm[\calG]{\DHKMSOL(f)}  
    =  \frac{R \bignorm[\tau]{\bigl(  \lambda_{\bsk}^{\rho'/\rho + 1}  \bigr)_{\bsk \in \calK}}} {\Lambda^{\rho'/\rho}} 
    = \frac{R \bignorm[\rho']{\bigl(  \lambda_{\bsk}  \bigr)_{\bsk \in \calK}}^{\rho'/\rho + 1}}
    {\Lambda^{\rho'/\rho}} = R \Lambda.
\end{equation*}
Moreover,
\begin{equation*}
    \norm[\calF]{f}  
    = \norm[\rho]{\left( \frac{\hf(\bsk)}{\lambda_{\bsk}} \right)_{\bsk \in \calK}}
    = \frac{R \bignorm[\rho]{\bigl(  \lambda_{\bsk}^{\rho'/\rho}  \bigr)_{\bsk \in \calK}}}{\Lambda^{\rho'/\rho}} 
    = \frac{R \bignorm[\rho']{\bigl(  \lambda_{\bsk}  \bigr)_{\bsk \in \calK}}^{\rho'/\rho}}
    {\Lambda^{\rho'/\rho}} = R.
\end{equation*}
This completes the proof.
\end{proof} \

Taking $\calK = \bbK$ in the lemma above, the norm of the solution operator can be expressed in terms of the norm of $\bslambda$ as follows:
\begin{equation} \label{DHKM:SOLNorm}
    \norm[\calF \to \calG]{\DHKMSOL}  = \sup_{\norm[\calF]{f} \le 1} \norm[\calG]{\DHKMSOL(f)} = \bignorm[\rho']{\bslambda}.
\end{equation}
We assume throughout this chapter that the weights are chosen to keep this norm finite, namely,
\begin{equation} \label{DHKM:SOLNormFinite}
    \bignorm[\rho']{\bslambda} < \infty.
\end{equation}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{An Illustrative Example}\label{DHKM:secexamp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consider the case of approximating functions defined over $[-1,1]^d$, using a Chebyshev polynomial basis.  The input function is denoted $f$, and the solution is $\DHKMSOL(f) = f$.  In this case,
	\begin{align*}
	f &  = \sum_{\bsk \in \bbN_0^d} \widehat{f}(\bsk) u_\bsk =: \DHKMSOL(f), 
	\qquad \bsk = (k_1, \ldots, k_d) \in \N_0^d,\\
    u_\bsk & := \prod_{\ell =1}^d \tu_{k_\ell} , 
    \qquad \tu_{k}(x) := \cos( k \cos^{-1}(x)) \quad \forall k \in \N_0.
	\end{align*}
For this example, let $\calF$ denote a Hilbert space of input functions where we choose $\bbK=\bbN_0^d$ and $\rho=2$,
\begin{equation}
\label{DHKM:IllExWts}
    \norm[\calF]{f} := \norm[2]{\left(\frac{\hf(\bsk)}{\lambda_{\bsk}}\right)_{\bsk \in \N_0^d}}, \qquad \text{where } \lambda_\bsk := \prod_{\substack{\ell =1\\ k_\ell > 0}}^d \frac{w_\ell}{k^r_\ell}, \quad r > 0.
\end{equation}
The $w_\ell$ are non-negative \emph{coordinate weights}, which embody the assumption that $f$ may depend more strongly on coordinates with larger $w_\ell$ than those with smaller $w_\ell$.  The definition of the $\calF$-norm implies that an input function must have series coefficients that decay quickly enough as the degree of the polynomial increases.  Larger $r$ implies smoother input functions.

Define the norm of the Hilbert space of outputs as
\begin{equation*}
      \norm[\calG]{\sum_{\bsk \in \N_0^d} \hg(\bsk) u_{\bsk}} : = \norm[2]{\bigl(\hg(\bsk) \bigr)_{\bsk \in \N_0^d}}.
\end{equation*}
Due to the ordering of the weights in \eqref{DHKM:lambda_order}, it is natural to approximate the solution using the first $n$ series coefficients as follows:
\begin{equation*} %\label{DHKM:Ex_APP_def}
   \DHKMAPP(f,n) := \sum_{i=1}^n \hf(\bsk_i) u_{\bsk_i} \qquad \forall f \in \calF, \ n \in \N.
\end{equation*}
The error of this approximation in terms of the norm on the output space, $\calG$, can be expressed as
\begin{equation*}
    \norm[\calG]{\DHKMSOL(f) - \DHKMAPP(f,n)} = \norm[2]{\bigl(\hf(\bsk_i) \bigr)_{i=n+1}^{\infty}}.
\end{equation*}
Here we have chosen $\tau = 2$ so $\rho'=\infty$.  If one has a fixed data budget, $n$, then $\DHKMAPP(f,n)$ is the best answer for certain classes of inputs in $\calF$ as for example balls, which are among the most prominent examples studied in the literature.  

We return to the example of functions on $[-1,1]^d$, using a Chebyshev polynomial basis, in Section \ref{DHKM:SecPilotTract} to discuss the information cost and computational complexity.  We perform some numerical experiments for this example in Section \ref{DHKM:numexamp_sec}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Approximation with inputs lying in a ball}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The optimal approximation  based on $n$ series coefficients of the input function is defined in terms of the series coefficients of the input function corresponding to the largest $\lambda_{\bsk}$ as follows:
\begin{equation} \label{DHKM:APP_def}
    \DHKMAPP : \calF \times \N_0 \to \calG, \quad  \DHKMAPP(f,0) = 0, \ \ \DHKMAPP(f,n) := \sum_{i=1}^n \hf(\bsk_i) v_{\bsk_i} \ \forall n \in \N.
\end{equation}
By the argument leading to \eqref{DHKM:SOL_A} it follows that 
\begin{equation} \label{DHKM:APP_Err_Coef}
    \norm[\calG]{\DHKMSOL(f) - \DHKMAPP(f,n)} = \norm[\tau]{\bigl(\hf(\bsk_i)\bigr)_{i=n+1}^\infty}.
\end{equation}
An upper bound on the approximation error follows from Lemma \ref{DHKM:Key_Lem}:
\begin{gather} \label{DHKM:Refined_APP_err}
    \norm[\calG]{\DHKMSOL(f) - \DHKMAPP(f,n) } \le \norm[\rho]{\left(\frac{\hf(\bsk_i)}{\lambda_{\bsk_i}}\right)_{i=n+1}^\infty}
    \bignorm[\rho']{\bslambda^{(n+1)}}, \\
    \intertext{where the tail of $\bslambda$ is defined by}
    \label{DHKM:taillambda}
     \bslambda^{(n)} : = \bigl(  \lambda_{\bsk_i}  \bigr)_{i = n}^{\infty}.
\end{gather}
This leads to the theorem below.  


\begin{theorem} \label{DHKM:APP_optimality_thm} Let $\calB_{R} : = \{ f \in \calF : \norm[\calF]{f} \le R \}$ denote the ball of radius $R$ in the space of input functions.  The error of the approximation defined in \eqref{DHKM:APP_def} is bounded tightly above as 
\begin{equation} \label{DHKM:APP_errorBd}
    \sup_{f \in \calB_R} \norm[\calG]{\DHKMSOL(f) - \DHKMAPP(f,n)}  \le R \, \bignorm[\rho']{\bslambda^{(n+1)}}.
\end{equation}
Moreover, the worst case error over $\calB_R$ of $\DHKMAPP'(\cdot,n)$, for any approximation based on $n$ series coefficients of the input function, can be no smaller.
\end{theorem}

\begin{proof}
The proof of \eqref{DHKM:APP_errorBd} follows immediately from \eqref{DHKM:Refined_APP_err} and  Lemma \ref{DHKM:Key_Lem}.  The optimality of $\DHKMAPP$ follows by bounding the error of an arbitrary approximation, $\DHKMAPP'$, applied to functions that mimic the zero function.

Let $\DHKMAPP'(0,n)$ depend on the series coefficients indexed by $\calJ  = \{\bsk'_1, \ldots, \bsk'_n\}$.  Use Lemma \ref{DHKM:Key_Lem} with $\calK = \bbK \setminus \calJ$ to choose $f$ to mimic the zero function, have norm $R$, and have as large a solution as possible by \eqref{DHKM:SOL_tight_ineq}, i.e.,
\begin{gather}
\nonumber
    \hf(\bsk'_1) = \cdots = \hf(\bsk'_n) = 0, \qquad \norm[\calF]{f} = R, \\ 
    \norm[\calG]{\DHKMSOL(f)} =  R \norm[\rho']{\left( \lambda_{\bsk} \right)_{\bsk \notin \calJ}}.  \label{DHKM:FoolFun}
\end{gather}
Then $\DHKMAPP'(\pm f,n) = \DHKMAPP'(0,n)$ because $f$ mimics the zero function, and
\begin{align*}
\MoveEqLeft{\sup_{f \in \calB_R} \norm[\calG]{\DHKMSOL(f) - \DHKMAPP(f,n)}} \\
& \ge \max_{\pm} \norm[\calG]{\DHKMSOL(\pm f) - \DHKMAPP'(\pm f,n)} =  \max_{\pm} \norm[\calG]{\DHKMSOL(\pm f) - \DHKMAPP'(0,n)} \\
& \ge \frac 12 \left [ \norm[\calG]{\DHKMSOL(f) - \DHKMAPP'(0,n)} 
+ \norm[\calG]{- \DHKMSOL(f) - \DHKMAPP'(0,n)}\right] \\
& \ge \norm[\calG]{\DHKMSOL(f)} 
 = R  \norm[\rho']{\left( \lambda_{\bsk} \right)_{\bsk \notin \calJ}} \qquad \text{by \eqref{DHKM:FoolFun}}.
\end{align*}
The ordering of the $\lambda_{\bsk}$ implies that $\norm[\rho']{\left( \lambda_{\bsk} \right)_{\bsk \notin \calJ}}$ for arbitrary $\calJ$ can be no smaller than the case $\calJ = \{\bsk_1, \ldots, \bsk_n\}$.  This completes the proof.
\end{proof} \

While approximation $\DHKMAPP$ is a key piece of the puzzle, our ultimate goal is an algorithm, $\DHKMALG : \calC \times [0,\infty)$, satisfying the absolute error criterion \eqref{DHKM:err_crit}. The non-adaptive Algorithm \ref{DHKM:BallAlg} satisfies this error criterion for $\calC  = \calB_R$.  

\begin{algorithm}[H]
\caption{Non-Adaptive $\DHKMALG$ for a Ball of Input Functions \label{DHKM:BallAlg}}
	\begin{algorithmic}
	\PARAM the Banach spaces $\calF$ and $\calG$, including the weights $\bslambda$; the ball radius, $R$; $\DHKMAPP$ satisfying \eqref{DHKM:APP_errorBd}
	\INPUT a black-box function, $f$; an absolute error tolerance, $\varepsilon>0$

    \Ensure Error criterion \eqref{DHKM:err_crit} for $\calC = \calB_{R}$

    \State Choose $n^* =  \min \left \{n \in \N_0 : \bignorm[\rho']{\bslambda^{(n+1)}} \le \varepsilon /R \right \}$

    \RETURN $\DHKMALG(f,\varepsilon) = \DHKMAPP(f,n^*)$
\end{algorithmic}
\end{algorithm}
We now show that this algorithm is optimal if the input set is a ball.
\begin{theorem}\label{DHKM:thm_cost_non_adapt}
The non-adaptive Algorithm \ref{DHKM:BallAlg} has an information cost for the set of input functions $\calC = \calB_R$ that is given by
\[
\DHKMCOST(\DHKMALG, \calB_R, \varepsilon,R') = \min \left \{n \in \N_0 : \bignorm[\rho']{\bslambda^{(n+1)}} \le \varepsilon /R \right \}, \qquad R’ \in (0, R].
\]
This algorithm is essentially optimal for the set of input functions $\calB_R$, namely,
\begin{multline*}
\DHKMCOST(\DHKMALG, \calB_R, \varepsilon,R') \le \COMP(\calB_R,\omega \varepsilon ,R') \\ \forall \, \varepsilon \in (0, \varepsilon_{\max}], \ R’ \in  [ R_{\min} , R], \ R \in [R_{\min}, \infty), 
\end{multline*}
where $\varepsilon_{\max}$ and $R_{\min}$ are arbitrary and fixed, and $\omega = R_{\min}/R$.
\end{theorem}

\begin{proof}  Fix positive $\varepsilon_{\max}$, $R_{\min}$, $R$, and $\omega$ as defined above.  For $0 < \varepsilon \le \varepsilon_{\max}$ and $R_{\min} \le R' \le R$, the information cost of non-adaptive Algorithm  \ref{DHKM:BallAlg} follows from its definition.  Let 
$
n^*(\varepsilon,R) : = \DHKMCOST(\DHKMALG, \calB_R, \varepsilon,R').
$
Construct an input function $f \in \calB_{R'}$ as in the proof of Theorem \ref{DHKM:APP_optimality_thm} with $\calJ = \{\bsk_1, \ldots, \bsk_{n^*(\omega \varepsilon,R')} \}$. By the argument in the proof of Theorem \ref{DHKM:APP_optimality_thm}, any algorithm in $\calA(\calB_{R'})$ that can approximate $\DHKMSOL(f)$ with an error no greater than $\omega \varepsilon$ must use at least $n^*(\omega \varepsilon,R')$ series coefficients.  Thus, 
\begin{align*}
\DHKMCOST(\DHKMALG, \calB_R, \varepsilon,R') & =  n^*(\varepsilon,R) 
= n^*(\varepsilon R'/R,R') \\
& \le n^*(\omega \varepsilon, R') \qquad \text{since } R'/R \ge \omega
\\
& \le \COMP(\calB_{R'},\omega \varepsilon, R') \le  \COMP(\calB_{R},\omega \varepsilon, R').
\end{align*}
Thus, Algorithm \ref{DHKM:BallAlg} is essentially optimal.
\end{proof} \

For Algorithm \ref{DHKM:BallAlg}, the information cost, $\DHKMCOST(\DHKMALG,\calB_R,\varepsilon, R)$, depends on the decay rate of the tail norm of the $\lambda_{\bsk_i}$.  This decay may be algebraic or exponential and also determines the problem complexity, $\COMP(\calB_R,\varepsilon, R)$, as a function of the error tolerance, $\varepsilon$.  


This theorem illustrates how an essentially optimal algorithm for solving a problem for a ball of input functions, $\calC = \calB_R$, can be non-adaptive.  However, as alluded to above, we claim that it is impractical to know a priori which ball your input function lies in.  On the other hand, in the situations described below where $\calC$ is a cone, we will show that $\calA(\calC)$ actually contains only adaptive algorithms via the lemma below.  The proof of this lemma follows directly from the definition of non-adaptivity.

\begin{lemma} \label{DHKM:NoNonAdpatLem}
For a given set of input functions, $\calC$, if  $\calA(\calC)$ contains any non-adaptive algorithms, then for every $\varepsilon > 0$,
\begin{equation*}
    \COMP(\calC,\varepsilon) : = \sup_{R > 0} \COMP(\calC,\varepsilon, R) < \infty.
\end{equation*}
\end{lemma}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bounding the Norm of the Input Function Based on a Pilot Sample} 
\label{DHKM:pilot_sec} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Cone and the Optimal Algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The premise of an adaptive algorithm is that the finite information we observe about the input function 
tells us something about what is not observed.  Let $n_1$ denote the number of pilot observations, based on the set of wavenumbers
\begin{equation} \label{DHKM:KOnedef}
    \calK_1 := \{\bsk_1, \ldots, \bsk_{n_1} \},
\end{equation}
where the $\bsk_i$ are defined by the ordering of the $\lambda_{\bsk}$ in \eqref{DHKM:lambda_order}.  Let $A$ be some constant inflation factor greater than one.  


Accordingly, we now define the cone of functions whose norm can be bounded well in terms of a pilot sample, $\{\hf(\bsk_1), \ldots, \hf(\bsk_{n_1})\}$. It is given by
\begin{equation} \label{DHKM:pilot_cone}
    \calC_{\boldsymbol{\lambda},n_1,A} = \left \{ f \in \calF : \norm[\calF]{f} \le A \norm[\rho]{\left( \frac{\hf(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i=1}^{n_1}} \right\}.
\end{equation}
Referring to error bound \eqref{DHKM:Refined_APP_err}, we see that the error of $\DHKMAPP(f,n)$ depends on the series coefficients not sampled.  The definition of $\calC_{\boldsymbol{\lambda},n_1,A}$ allows us to bound these as follows: 
\begin{align*}
     \MoveEqLeft{\norm[\rho]{\left(\frac{\hf(\bsk_i)}{\lambda_{\bsk_i}}\right)_{i=n+1}^\infty}} \\
     & =  \left[ \norm[\calF]{f}^\rho -  \norm[\rho]{\left(\frac{\hf(\bsk_i)}{\lambda_{\bsk_i}}\right)_{i=1}^n}^\rho
    \right]^{1/\rho} \qquad \forall f \in \calF \\
    &  \le  \left[ A^\rho \norm[\rho]{\left( \frac{\hf(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i=1}^{n_1}}^\rho -  \norm[\rho]{\left(\frac{\hf(\bsk_i)}{\lambda_{\bsk_i}}\right)_{i=1}^n}^\rho
    \right]^{1/\rho} \quad \forall f \in \calC_{\boldsymbol{\lambda},n_1,A}.
\end{align*}
This inequality together with error bound \eqref{DHKM:Refined_APP_err} implies the data-based error bound 
\begin{subequations} \label{DHKM:pilot_errbd}
\begin{equation}
\norm[\calG]{\DHKMSOL(f) - \DHKMAPP(f,n)}  \le \DHKMERRN  \qquad \forall f \in \calC_{\boldsymbol{\lambda},n_1,A},
\end{equation}
where 
\begin{multline} \label{ErrNDef}
\DHKMERRN \\
    : =  
    \left[ A^\rho \norm[\rho]{\left( \frac{\hf(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i=1}^{n_1}}^\rho -  \norm[\rho]{\left(\frac{\hf(\bsk_i)}{\lambda_{\bsk_i}}\right)_{i=1}^n}^\rho \right]^{1/\rho} 
    \, \bignorm[\rho']{\bslambda^{(n+1)}} , 
    \\ \forall n \ge n_1.
\end{multline}
\end{subequations}
This error bound decays as $\bignorm[\rho]{\bigl( f(\bsk_i)/\lambda_{\bsk_i} \bigr)_{i=1}^n}$ increases and as the tail norm of the $\lambda_{\bsk_i}$ decreases.  This data-driven error bound underlies  Algorithm \ref{DHKM:PilotConeAlg}, which is successful for the cone of input functions, $\calC_{\boldsymbol{\lambda},n_1,A}$, defined in \eqref{DHKM:pilot_cone}:

\begin{algorithm}
	\caption{$\DHKMALG$ Based on a Pilot Sample\label{DHKM:PilotConeAlg}} 
	\begin{algorithmic}
	\PARAM the Banach spaces $\calF$ and $\calG$, including the weights $\bslambda$; an initial sample size, $n_1 \in \N$; an inflation factor, $A > 1$; $\DHKMAPP$ satisfying \eqref{DHKM:Refined_APP_err}
		\INPUT a black-box function, $f$; an absolute error tolerance,
		$\varepsilon>0$

\Ensure Error criterion \eqref{DHKM:err_crit} for  the cone defined in \eqref{DHKM:pilot_cone}

\State Let $n \leftarrow n_1 -1$
\Repeat

\State Let $n \leftarrow n + 1$

\State Compute $\DHKMERRN$ as defined in \eqref{DHKM:pilot_errbd}

\Until $\DHKMERRN \le \varepsilon$

\RETURN $\DHKMALG(f,\varepsilon) = \DHKMAPP(f,n)$

\end{algorithmic}
\end{algorithm}

\begin{theorem} \label{DHKM:PilotCostThm}
Algorithm \ref{DHKM:PilotConeAlg} yields an answer satisfying absolute error criterion \eqref{DHKM:err_crit}, i.e., $\DHKMALG \in \calA(\calC_{\boldsymbol{\lambda},n_1,A})$ for $\calC_{\boldsymbol{\lambda},n_1,A}$ defined in \eqref{DHKM:pilot_cone}.  The information cost is
\begin{multline} \label{DHKM:PilotConeAlg_cost}
    \DHKMCOST(\DHKMALG,\calC_{\boldsymbol{\lambda},n_1,A},\varepsilon,R) \\
    = \min \left \{n \ge n_1 : \bignorm[\rho']{\bslambda^{(n+1)}} \,
    \le \varepsilon/[(A^\rho -1)^{1/\rho}R] \right \}.
\end{multline}
There exist positive $\varepsilon_{\max}$ and $R_{\min}$ for which the computational complexity has the lower bound
\begin{multline} \label{DHKM:PilotConeAlg_comp}
        \COMP(\calC_{\boldsymbol{\lambda},n_1,A},\varepsilon,R) \ge \min \left \{n \ge n_1 : \bignorm[\rho']{\bslambda^{(n+1)}} \,
    \le 2\varepsilon/[(1 - 1/A) R] \right \} \\
    \forall \varepsilon \in (0, \varepsilon_{\max}], \ R \in [R_{\min}, \infty).
\end{multline}
Algorithm \ref{DHKM:PilotConeAlg} is essentially optimal.  Moreover, $\calA(\calC_{\boldsymbol{\lambda},n_1,A})$ contains only adaptive algorithms.
\end{theorem}

\begin{proof} 
The upper bound on the information cost of this algorithm is obtained by noting that 
\begin{align*}
    \MoveEqLeft[1]{\DHKMCOST(\DHKMALG,\calC_{\boldsymbol{\lambda},n_1,A},\varepsilon,R)} \\
    & = \max_{f \in \calC \cap \calB_{R}} \min \left \{n \ge n_1 : \DHKMERRN \le \varepsilon \right \} \\
     & \le \max_{f \in \calC \cap \calB_{R}} \min \left \{n \ge n_1 : 
     (A^\rho -1)^{1/\rho} \norm[\rho]{\left( \frac{\hf(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i=1}^{n_1}} \, 
     \bignorm[\rho']{\bslambda^{(n+1)}}
    \le \varepsilon \right \} \\   
     & \le \min \left \{n \ge n_1 : 
     (A^\rho -1)^{1/\rho} R \,\bignorm[\rho']{\bslambda^{(n+1)}}
    \le \varepsilon \right \},  
\end{align*}
since $\bignorm[\rho]{\bigl( \hf(\bsk_i)/\lambda_{\bsk_i} \bigr)_{i=1}^{n_1}} \le \bignorm[\rho]{\bigl( \hf(\bsk_i)/\lambda_{\bsk_i} \bigr)_{i=1}^{n}} \le  \norm[\calF]{f} \le R$ for all $f \in \calB_R$, $n \ge n_1$.  Moreover, this inequality is tight for some $f \in \calC_{\boldsymbol{\lambda},n_1,A} \cap \calB_{R}$, namely, those certain $f$ for which $\hf(\bsk_i) = 0$ for $i > n_1$.  This completes the proof of \eqref{DHKM:PilotConeAlg_cost}.

To prove the lower complexity bound, choose $\varepsilon_{\max}$ and $R_{\min}$ such that 
\[
\bignorm[\rho']{\bigl(  \lambda_{\bsk_i}  \bigr)_{i = n_1+1}^{\infty}} \,
    > 2\varepsilon_{\max}/[(1 - 1/A) R_{\min}].
    \]
Let $\DHKMALG'$ be any algorithm that satisfies the error criterion, \eqref{DHKM:err_crit}, for this choice of $\calC_{\boldsymbol{\lambda},n_1,A}$ in \eqref{DHKM:pilot_cone}.   Fix $R \in [R_{\min},\infty)$ and $\varepsilon \in (0,\varepsilon_{\max}]$ arbitrarily.  Two fooling functions will be constructed of the form $f_\pm = f_1 \pm f_2$.  

The input function $f_1$ is defined via its series coefficients as in Lemma \ref{DHKM:Key_Lem}, having nonzero coefficients only for $\bsk \in \calK_1=\{\bsk_1, \ldots, \bsk_{n_1}\}$:
\begin{equation*}
    \bigabs{\hf_1(\bsk)} = \begin{cases} \displaystyle \frac{R (1+1/A) \lambda_{\bsk}^{\rho'/\rho + 1}}{2\bignorm[\rho']{\bigl(  \lambda_{\bsk}  \bigr)_{\bsk \in \calK_1}}^{\rho'/\rho}}, &  \bsk \in \calK_1, \\
    0, & \bsk \notin \calK_1,
    \end{cases}
   \qquad \norm[\calF]{f_1} = \frac{R(1 + 1/A)}{2}.
\end{equation*}
Suppose that $\DHKMALG'(f_1,\varepsilon)$ samples the series coefficients $\hf_1(\bsk)$ for $\bsk \in \calJ$, and let $n$ denote the cardinality of $\calJ$.  

Now, construct the input function $f_2$, having zero coefficients for $\bsk \in \calJ$ and also as in Lemma \ref{DHKM:Key_Lem}:
\begin{gather}
\nonumber
    \bigabs{\hf_2(\bsk)} = \begin{cases} \displaystyle \frac{R (1-1/A) \lambda_{\bsk}^{\rho'/\rho + 1}}{2\bignorm[\rho']{\bigl(  \lambda_{\bsk}  \bigr)_{\bsk \notin \calJ}}^{\rho'/\rho}}, &  \bsk \notin \calJ, \\
    0, & \bsk \in \calJ, 
    \end{cases}
    \qquad \norm[\calF]{f_2} = \frac{R(1 - 1/A)}{2}, \\
    \label{DHKM:SOLf2bd}
    \norm[\calG]{\DHKMSOL(f_2)} = \frac{R(1 - 1/A)}{2} \, \bignorm[\rho']{\bigl(  \lambda_{\bsk}  \bigr)_{\bsk \notin \calJ}}.
\end{gather}

Let $f_{\pm} = f_1 \pm f_2$.  By the definitions above, it follows that
\begin{align}
\nonumber
    \norm[\calF]{f_{\pm}} &= \norm[\calF]{ f_1 \pm f_2 } \le \norm[\calF]{ f_1} + \norm[\calF]{ f_2 } =  R, \\
    \nonumber
    \norm[\rho]{\left( \frac{\hf_\pm(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i=1}^{n_1}} 
    & = \norm[\rho]{\left( \frac{\hf_1(\bsk_i) \pm \hf_2(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i=1}^{n_1}} \\
    \nonumber
    & \ge \norm[\rho]{\left( \frac{\hf_1(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i=1}^{n_1}} - \norm[\rho]{\left( \frac{\hf_2(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i=1}^{n_1}} \\
    \nonumber
    & \ge \norm[\calF]{ f_1} - \norm[\calF]{ f_2 } =  \frac{R}{A} \ge \frac{\norm[\calF]{f_{\pm}}}{A}.
\end{align}
Therefore, $f_\pm \in \calC_{\boldsymbol{\lambda},n_1,A} \cap \calB_R$.  Moreover, since the series coefficients for $f_\pm$ are the same for $\bsk \in \calJ$, it follows that $\DHKMALG'(f_+,\varepsilon) = \DHKMALG'(f_-,\varepsilon)$.  Thus, $\DHKMSOL(f_{+})$ must be quite similar to $\DHKMSOL(f_{-})$.

Using an argument like that in the proof of  Theorem \ref{DHKM:APP_optimality_thm}, it follows that 
\begin{align*}
\varepsilon & \ge \max_{\pm} \norm[\calG]{\DHKMSOL(f_{\pm}) - \DHKMALG'(f_{\pm},\varepsilon)} 
=  \max_{\pm} \norm[\calG]{\DHKMSOL(f_{\pm}) - \DHKMALG'(f_{+},\varepsilon)} \\
& \ge \frac 12 \left [ \norm[\calG]{\DHKMSOL(f_{+}) - \DHKMALG'(f_{+},\varepsilon)} 
+ \norm[\calG]{\DHKMSOL(f_{-}) - \DHKMALG'(f_{+},\varepsilon)}  \right] \\
& \ge \frac 12 \norm[\calG]{\DHKMSOL(f_+ - f_-)} = \norm[\calG]{\DHKMSOL(f_2)} 
=\frac{R(1 - 1/A)}{2} \, \bignorm[\rho']{\bigl(  \lambda_{\bsk}  \bigr)_{\bsk \notin \calJ}} \qquad \text{by \eqref{DHKM:SOLf2bd}} \\
& \ge \frac{R(1 - 1/A)}{2} \, \bignorm[\rho']{\bslambda^{(n+1)}} ,
\end{align*}
by the ordering of the $\bsk$ in \eqref{DHKM:lambda_order}.  By the choice of $R_{\min}$ and $\varepsilon_{\max}$ above, it follows that $n > n_1$.  This inequality then implies lower complexity bound \eqref{DHKM:PilotConeAlg_comp}. Because $\lim_{R \to \infty} \COMP(\calC_{\boldsymbol{\lambda},n_1,A}, \varepsilon,R) = \infty$  it follows from Lemma \ref{DHKM:NoNonAdpatLem} that $\calA(\calC_{\boldsymbol{\lambda},n_1,A})$ contains only adaptive algorithms.

The essential optimality of Algorithm \ref{DHKM:PilotConeAlg} follows by observing that 
\[
\DHKMCOST(\DHKMALG,\calC_{\boldsymbol{\lambda},n_1,A},\varepsilon,R) \le \COMP(\calC_{\boldsymbol{\lambda},n_1,A},\omega \varepsilon,R) \qquad \text{for } \omega = \frac{1-1/A}{2(A^\rho -1)^{1/\rho}}.
\]
This satisfies definition \eqref{DHKM:EssentialOpt}.  
\end{proof} \

The above derivation assumes that $A > 1$.  If $A =1$, then our cone consists of functions whose only nonzero series coefficients are for wavenumbers in the set $\{\bsk_1, \ldots, \bsk_{n_1}\}$.  The exact solution can be constructed using only the pilot sample.  Our algorithm is then non-adaptive, but succeeds for input functions in the cone $\calC_{\boldsymbol{\lambda},n_1,A}$, which is an unbounded set.

We may not be able to guarantee that a particular $f$ of interest lies in our cone, $\calC_{\boldsymbol{\lambda},n_1,A}$, but the definition of $\DHKMERRN$ in \eqref{ErrNDef} provides a necessary condition for  $f$ to lie in $\calC_{\boldsymbol{\lambda},n_1,A}$, namely,
\begin{equation} \label{DHKM:PilotConeNecessary}
    \norm[\rho]{\left( \frac{\hf(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i =1}^{n}} \le A
    \norm[\rho]{\left( \frac{\hf(\bsk)}{\lambda_{\bsk}} \right)_{\bsk \in \calK_1}} \qquad \forall n \in \NN.
\end{equation}
If condition \eqref{DHKM:PilotConeNecessary} is violated in practice, then $f \notin \calC_{\boldsymbol{\lambda},n_1,A}$, and Algorithm \ref{DHKM:PilotConeAlg} may output an incorrect answer.  The remedy is to make $\calC_{\boldsymbol{\lambda},n_1,A}$ more inclusive by increasing the inflation factor, $A$, and/or the pilot sample size, $n_1$.


Our $\calC_{\boldsymbol{\lambda},n_1,A}$ is a cone for which a pilot sample of the input function allows you to bound its norm.  An alternative is to define a cone for which a weaker norm of the function provides an upper bound on the original norm.  Here is such a cone:
\begin{multline} \label{DHKM:altconedef}
    \calC'_{\boldsymbol{\lambda}, \boldsymbol{\omega}, A'}:=\{ f \in \calF : \norm[\calF]{f} \le A'\norm[\calF']{f}\}, \\ \text{where } \norm[\calF']{f} :=\norm[\rho]{\left( \frac{\hf(\bsk_i)\omega_{i}}{\lambda_{\bsk_i}} \right)_{i =  1}^n} \text{ and } \omega_1 \ge \omega_2 \ge \cdots.
\end{multline}
The norm $\norm[\calF']{\cdot}$ is weaker than the norm $\norm[\calF]{\cdot}$, so this cone is a strict subset of $\calF$.  The following proposition describes how the cones defined in \eqref{DHKM:pilot_cone} and \eqref{DHKM:altconedef} are related.
\begin{proposition}
If the parameters $A,A',A'', n_1,$ and $\boldsymbol{\omega} = (\omega_1, \omega_2, \ldots)$ satisfy
\[ 
\omega_1A'\left[\frac{1 + (\omega_{n_1+1}/\omega_1)^\rho}{1 - (\omega_{n_1+1}A')^\rho}\right]^{1/\rho}
\le A \le \omega_{n_1} A'' \text{ and} \qquad  \omega_{n_1+1}A' < 1, 
\]
then the two types of cones defined in \eqref{DHKM:pilot_cone} and \eqref{DHKM:altconedef} include one another:
\[
\calC'_{\boldsymbol{\lambda}, \boldsymbol{\omega}, A'}
\subseteq 
\calC_{\boldsymbol{\lambda}, n_1, A}
\subseteq
\calC'_{\boldsymbol{\lambda}, \boldsymbol{\omega}, A''}.
\]
\end{proposition}

\begin{proof}
Let us prove $
\calC_{\boldsymbol{\lambda}, n_1, A} \subseteq \calC'_{\boldsymbol{\lambda}, \boldsymbol{\omega}, A''}$ first.
If $f \in \calC_{\boldsymbol{\lambda}, n_1, A}$, then by the definition of $\calC_{\boldsymbol{\lambda}, n_1, A}$ we have
\begin{equation*}
    \norm[\calF]{f} \le A \norm[\rho]{\left( \frac{\hf(\bsk_i)}{\lambda_{\bsk_i}} \right)_{i = 1} ^{ n_1}}
     \le A \omega_{n_1}^{-1} \norm[\rho]{\left( \frac{\hf(\bsk_i)\omega_{\bsk_i}}{\lambda_{\bsk_i}} \right)_{i =1} ^{n_1}}
     \le A \omega_{n_1}^{-1} \norm[\calF']{f}.
\end{equation*}
Thus, if $A\omega_{n_1}^{-1} \le A''$, i.e. $A \le \omega_{n_1} A'' $, then
we must have $f \in \calC'_{\boldsymbol{\lambda}, \boldsymbol{\omega}, A''}$.  So, $
\calC_{\boldsymbol{\lambda}, n_1, A} \subseteq \calC'_{\boldsymbol{\lambda}, \boldsymbol{\omega}, A''}$.

For the proof that 
$\calC'_{\boldsymbol{\lambda}, \boldsymbol{\omega}, A'}
\subseteq 
\calC_{\boldsymbol{\lambda}, n_1, A}$, 
suppose $f \in \calC'_{\boldsymbol{\lambda},\boldsymbol{\omega},  A'}$. Then we have
\begin{align*}
    \norm[\calF']{f}^\rho- \norm[\rho]{\biggl ( \frac{\hf(\bsk_i) \omega_i }{\lambda_{\bsk_i}} \biggr) _{i=1}^{n_1}}^\rho 
	& = \norm[\rho]{\biggl ( \frac{\hf(\bsk_i) \omega_i }{\lambda_{\bsk_i}} \biggr) _{i=n_1 + 1}^{\infty}}^\rho 
     \le \omega_{n_1+1}^\rho \norm[\rho]{\biggl ( \frac{\hf(\bsk_i) }{\lambda_{\bsk_i}} \biggr) _{i=n_1 + 1}^{\infty}}^\rho \\
     & = \omega_{n_1+1}^\rho \left[ \norm[\calF]{f}^\rho - \norm[\rho]{\biggl ( \frac{\hf(\bsk_i) }{\lambda_{\bsk_i}} \biggr) _{i=1}^{n_1}}^\rho \right ]\\	
     & \le \omega_{n_1+1}^\rho \left[ A'{}^\rho \norm[\calF']{f}^\rho - \omega_1^{-\rho} \norm[\rho]{\biggl ( \frac{\hf(\bsk_i) \omega_i}{\lambda_{\bsk_i}} \biggr) _{i=1}^{n_1}}^\rho \right ].
\end{align*}
Assuming $\omega_{n_1+1}A' < 1$ and rearranging the above terms, we obtain
\begin{align*}
\norm[\calF']{f}^\rho & \le \frac{1 + (\omega_{n_1+1}/\omega_1)^\rho}{1 - (\omega_{n_1+1}A')^\rho} \norm[\rho]{\biggl ( \frac{\hf(\bsk_i) \omega_i }{\lambda_{\bsk_i}} \biggr) _{i=1}^{n_1}}^\rho, \\
	\norm[\calF]{f} & \le \omega_1A'\left[\frac{1 + (\omega_{n_1+1}/\omega_1)^\rho}{1 - (\omega_{n_1+1}A')^\rho}\right]^{1/\rho} \norm[\rho]{\biggl ( \frac{\hf(\bsk_i)}{\lambda_{\bsk_i}} \biggr) _{i=1}^{n_1}}.
\end{align*}
Hence, if $\omega_1A'\left[\frac{1 + (\omega_{n_1+1}/\omega_1)^\rho}{1 - (\omega_{n_1+1}A')^\rho}\right]^{1/\rho} \le A$, it follows that $f \in \calC_{\boldsymbol{\lambda}, n_1, A}$ and so
we obtain $
\calC'_{\boldsymbol{\lambda}, \boldsymbol{\omega}, A'}
\subseteq
\calC_{\boldsymbol{\lambda}, n_1, A}
$.
\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bounds on the Information Cost for $\rho = \tau$, $\rho'=\infty$}\label{DHKM:revisexamp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


We now derive upper and lower bounds on the information costs of Algorithms \ref{DHKM:BallAlg} and \ref{DHKM:PilotConeAlg} for the case  $\rho = \tau$ and $\rho' = \infty$, which includes the example introduced in Section \ref{DHKM:secexamp}.  For $\rho'=\infty$, $\bignorm[\rho']{\bslambda^{(n+1)}} = \lambda_{\bsk_{n+1}}$.  To facilitate these bounds we establish a couple of common lemmas.  Again we refer the reader to  \cite[Section 11.11]{Pie78a}.

\begin{lemma}\label{DHKM:lambdineq}
Consider the ordered weights,
$\lambda_{\bsk_{1}} \ge \lambda_{\bsk_{2}} \ge \cdots > 0,$ and recall from \eqref{DHKM:taillambda} that $\bslambda^{(n)} = (\lambda_{\bsk_n}, \lambda_{\bsk_{n+1}}, \ldots )$.  It follows that 
\[ 
\lambda_{\bsk_{n+1}} \le \frac{\norm[p]{\bslambda}}{n^{1/p}} \ \ \text{and} \ \ 
 \sup_{n \ge n_{\min}} \lambda_{\bsk_{n}} n^{1/p} \ge \frac{\bignorm[p\eta]{\bslambda^{(n_{\min})}}}{\zeta(\eta)^{1/(p\eta)}} \quad \forall p>0, \ \eta > 1, \ n_{\min} \in \bbN.
\]
If $\norm[p]{\bslambda} = \infty$ or $\sup_{n \ge n_{\min}} \lambda_{\bsk_{n}} n^{1/p} = \infty$, we consider these inequalities to be trivially true.
\end{lemma}
\begin{proof}
Since the $\lambda_{\bsk_i}$ are non-increasing it follows that 
\begin{equation*}
    n \lambda_{\bsk_{n+1}}^p \le 
    \lambda_{\bsk_{1}}^p + \lambda_{\bsk_{2}}^p + \cdots 
    + \lambda_{\bsk_{n}}^p  \le \sum_{\bsk \in \bbK} \lambda_{\bsk}^p = \norm[p]{\bslambda}^p \qquad \forall p > 0.
\end{equation*}
Dividing both sides by $n$ and taking the $p^{\text{th}}$ root completes the proof of the first inequality.  

To prove the second inequality, we employ H\"older's inequality to show that
\begin{equation*}
    \bignorm[p\eta]{\bslambda^{(n_{\min})}}^{p\eta} 
    = \sum_{n=n_{\min}}^\infty \frac{\lambda_{\bsk_n}^{p\eta} n^\eta }{n^\eta} 
    \le \sup_{n \ge n_{\min}}\lambda_{\bsk_n}^{p\eta} n^\eta \ \sum_{n=n_{\min}}^\infty \frac{1}{n^\eta} \le \sup_{n \ge n_{\min}}\lambda_{\bsk_n}^{p\eta} n^\eta  \zeta(\eta),
\end{equation*}
where $\zeta$ is the Riemann zeta function.  The proof is completed by taking the $p\eta^{\text{th}}$ root and rearranging the terms.
\end{proof}

\bigskip

These upper and lower bounds together with Theorems \ref{DHKM:thm_cost_non_adapt} and \ref{DHKM:PilotCostThm} can be used to relate the information costs of Algorithms \ref{DHKM:BallAlg} and \ref{DHKM:PilotConeAlg} to the decay rate of the elements of $\bslambda$.

\begin{theorem} \label{DHKM:thm:costbdspilot}
If the elements of $\bslambda$ decay fast enough so that $\norm[p]{\bslambda} < \infty$ and $\rho'=\infty$, then the information costs of Algorithms \ref{DHKM:BallAlg} and \ref{DHKM:PilotConeAlg} are bounded above by
\begin{align*}
    \text{Algorithm \ref{DHKM:BallAlg}:} \quad& \DHKMCOST(\DHKMALG,\calB_R,\varepsilon, R') 
    \le \left \lceil  \left(\frac{R \norm[p]{\bslambda}}{\varepsilon}\right)^p     \right \rceil, \qquad \forall \varepsilon, \ 0 < R' < R, \\
    \text{Algorithm \ref{DHKM:PilotConeAlg}:} \quad& \DHKMCOST(\DHKMALG,\calC_{\bslambda,n_1,A},\varepsilon, R) 
    \\ & \qquad \qquad \le \max \left( n_1, 
    \left \lceil  \left(\frac{[(A^\rho -1)^{1/\rho}R] \norm[p]{\bslambda}}{\varepsilon}\right)^p \right \rceil \right).
    \end{align*}
Conversely, for fixed $R', R$ with $0 < R' < R$, if either
\begin{align*}
    \DHKMCOST(\DHKMALG,\calB_R,\varepsilon, R') 
    \le C \varepsilon^{-p} & \quad \forall \varepsilon \in (0,\varepsilon_{\max}] \quad  \text{for Algorithm \ref{DHKM:BallAlg}, or }  \\
     \DHKMCOST(\DHKMALG,\calC_{\bslambda,n_1,A},\varepsilon, R) 
    \le C \varepsilon^{-p} & \quad \forall \varepsilon \in (0,\varepsilon_{\max}] \quad \text{for Algorithm \ref{DHKM:PilotConeAlg}},
    \end{align*}
then $\norm[p\eta]{\bslambda} < \infty$ for all $\eta > 1$.  Since Algorithms \ref{DHKM:BallAlg} and \ref{DHKM:PilotConeAlg} are essentially optimal, the above inequalities provide upper and lower asymptotic bounds on  $\COMP(\calB_R,\varepsilon,R')$ and $\COMP(\calC_{\bslambda,n_1,A},\varepsilon,R)$.
\end{theorem}
\begin{proof}
We give the proof for Algorithm \ref{DHKM:PilotConeAlg}, which is similar to the proof for Algorithm \ref{DHKM:BallAlg}.  Recall that for $\rho'=\infty$, $\bignorm[\rho']{\bslambda^{(n+1)}} = \lambda_{\bsk_{n+1}}$. From \eqref{DHKM:PilotConeAlg_cost} it follows that the information cost for  Algorithm \ref{DHKM:PilotConeAlg} is
\begin{align*} 
    \DHKMCOST(\DHKMALG,\calC_{\boldsymbol{\lambda},n_1,A},\varepsilon,R)
    & = \min \left \{n \ge n_1 : \lambda_{\bsk_{n+1}}
    \le \frac{\varepsilon}{[(A^\rho -1)^{1/\rho}R]} \right \} \\
  & \le  \min \left \{n \ge n_1 : \norm[p]{\bslambda}n^{-1/p}
    \le \frac{\varepsilon}{[(A^\rho -1)^{1/\rho}R]} \right \} \\
    & \qquad \qquad \text{by Lemma \ref{DHKM:lambdineq} since } \lambda_{\bsk_{n+1}} \le \norm[p]{\bslambda}n^{-1/p}\\
  & = \left \lceil  \left(\frac{[(A^\rho -1)^{1/\rho}R] \norm[p]{\bslambda}}{\varepsilon}\right)^p \right \rceil.
\end{align*}

Now suppose that $\DHKMCOST(\DHKMALG,\calC_{\bslambda,n_1,A},\varepsilon, R) 
    \le C \varepsilon^{-p}$ for all $\varepsilon \in (0,\varepsilon_{\max}]$.  Since the information cost is an integer, this means that $\DHKMCOST(\DHKMALG,\calC_{\bslambda,n_1,A},\varepsilon, R) 
    \le \lfloor C \varepsilon^{-p} \rfloor$  and let $n_{\min} = \lfloor C \varepsilon_{\max}^{-p} \rfloor +1$. 
    According to Lemma \ref{DHKM:lambdineq}, it follows that for all $\eta > 1$,
    \begin{align*}
       \bignorm[p\eta]{\bslambda^{(n_{\min})}}  
       &\le  \zeta(\eta)^{1/(p\eta)} \sup_{n \ge n_{\min}} \lambda_{\bsk_{n}} n^{1/p} \\
       &=  \zeta(\eta)^{1/(p\eta)} \sup_{0 < \varepsilon \le \varepsilon_{\max}} \lambda_{\bsk_{\lfloor C \varepsilon^{-p} \rfloor+1}} (\lfloor C \varepsilon^{-p} \rfloor+1)^{1/p} \\
        & \hspace{3cm} \text{by the definition of } n_{\min} \\
        & \le  \zeta(\eta)^{1/(p\eta)} \sup_{0 < \varepsilon \le \varepsilon_{\max}} \frac{\varepsilon \, (\lfloor C \varepsilon^{-p} \rfloor+1)^{1/p}}{
        AR} < \infty\\
        & \hspace{3cm} \text{since } \DHKMCOST(\DHKMALG,\calC_{\bslambda,n_1,A},\varepsilon, R) 
    \le \lfloor C \varepsilon^{-p} \rfloor.
    \end{align*}
    Since $\bignorm[p\eta]{\bslambda^{(n_{\min})}}$ is finite, it follows that $\bignorm[p\eta]{\bslambda}$ is finite.
\end{proof}

\bigskip

To be more concrete, we consider the situation where the $\lambda_{\bsk}$ are specified in terms of positive \emph{coordinate weights}, $\bsw = (w_1, \ldots, w_d)$, and positive \emph{smoothness weights}, $\bss = (s_1, s_2, \ldots)$:
\begin{equation}
    \label{DHKM:prodwts}
\lambda_{\bsk}  := \prod_{\substack{\ell =1\\ k_\ell > 0}}^d w_\ell s_{k_\ell}, \qquad \bsk \in \bbK :=\NN_0^d, \ d \in \NN.
\end{equation}
This is a generalization of our illustrative example, \eqref{DHKM:IllExWts}, in Section \ref{DHKM:secexamp} where $\bss = (1, 2^{-r}, 3^{-r}, \ldots )$.  
This form of the $\lambda_{\bsk}$ is also considered in Sections \ref{DHKM:tracking_sec} and  \ref{DHKM:smoothimportance_sec}.

\begin{lemma}\label{DHKM:prodwtsupperbound}
For $\bslambda = \bigl(\lambda_{\bsk} \bigr)_{\bsk \in \bbN_0^d}$ defined in \eqref{DHKM:prodwts}
we have the following lower and upper bounds on $\norm[p]{\bslambda}$.  It holds that
\begin{gather*}
\norm[p]{\bss} \norm[p]{\bsw} \le \norm[p]{\bslambda}\le \exp\left(\frac 1p \norm[p]{\bss}^p \norm[p]{\bsw}^p  \right) \qquad \text{for general } \bss, \\
[\zeta(pr)]^{1/p} \norm[p]{\bsw} \le \norm[p]{\bslambda} \le \exp\left(\frac {\zeta(pr)}p \norm[p]{\bsw}^p  \right) \qquad \text{for } \bss = (1, 2^{-r}, \ldots ), \ pr > 1.
\end{gather*}
\end{lemma}

\begin{proof}
The proof is constructed first for general $\bss$.  For the particular form of $\bss$ introduced in \eqref{DHKM:IllExWts} it follows that $\norm[p]{\bss}^p = \zeta(pr)$ for $pr > 1$.

By straightforward calculation and \eqref{DHKM:prodwts},
\begin{equation} \label{DHKM:lambdaprodwts}
   \norm[p]{\bslambda}^ p 
   = \sum_{\bsk \in \NN_0^d} \lambda_{\bsk}^p  
   = \prod_{\ell =1}^d\left(1+ w_\ell^p \sum_{k=1}^{\infty}s_{k}^p\right) 
   = \prod_{\ell =1}^d\left(1+ w_\ell^p \norm[p]{\bss}^p \right).
\end{equation}
A lower bound is obtained by noting from the equation above that 
\begin{equation*}
   \norm[p]{\bslambda}^ p 
   = \prod_{\ell =1}^d\left(1+ w_\ell^p \norm[p]{\bss}^p \right)  
   \ge  \norm[p]{\bss}^p \sum_{\ell =1}^d w_\ell^p = \norm[p]{\bss}^p \norm[p]{\bsw}^p.
\end{equation*}
Taking the $p^{\text{th}}$ root completes the proof of the lower bound.  

For the upper bound \eqref{DHKM:lambdaprodwts} implies that 
\begin{align*}
   \norm[p]{\bslambda}^ p
   & = \prod_{\ell =1}^d\left(1+ w_\ell^p \norm[p]{\bss}^p \right)
   = \exp\left(\sum_{\ell = 1}^d \log\bigl(1 + w_\ell^{p}\norm[p]{\bss}^p \bigr) \right)\\
 &  \le \exp\left(\sum_{\ell = 1}^d  w_\ell^{p} \norm[p]{\bss}^p \right) = \exp\left(\norm[p]{\bsw}^p\norm[p]{\bss}^p \right)
\quad \text{since }\log(1+x) \le x \ \forall x\ge 0.
\end{align*}
Again, taking the $p^{\text{th}}$ root completes the proof for general $\bss$.  
\end{proof}

\bigskip

Theorem \ref{DHKM:thm:costbdspilot} and Lemma \ref{DHKM:prodwtsupperbound} imply bounds on the information costs of Algorithms \ref{DHKM:BallAlg} and \ref{DHKM:PilotConeAlg} for the function spaces defined in the illustrative example in Section \ref{DHKM:secexamp}.


\begin{corollary}\label{DHKM:cor:illex} 
For the function spaces defined in the illustrative example in Section \ref{DHKM:secexamp}, for all $p > 1/r$:
\begin{align*}
    \text{Algorithm \ref{DHKM:BallAlg}:} \quad& \DHKMCOST(\DHKMALG,\calB_R,\varepsilon, R') 
    \le \left \lceil  \left(\frac{R}{\varepsilon}\right)^p  \exp\left( \zeta(pr) \norm[p]{\bsw}^p  \right)    \right \rceil, \\
    \text{Algorithm \ref{DHKM:PilotConeAlg}:} \quad& \DHKMCOST(\DHKMALG,\calC_{\bslambda,n_1,A},\varepsilon, R) 
    \\ & \qquad \qquad \le \max \left( n_1, 
    \left \lceil  \left(\frac{(A^\rho-1)^{1/\rho}R}{\varepsilon}\right)^p  \exp\left( \zeta(pr) \norm[p]{\bsw}^p  \right)    \right \rceil \right).
    \end{align*}
Furthermore, these information costs cannot grow any slower than $\calO(\varepsilon^{-1/r})$ for $\varepsilon \downarrow 0$. Since Algorithms \ref{DHKM:BallAlg} and \ref{DHKM:PilotConeAlg} are essentially optimal, the above inequalities provide upper and lower asymptotic bounds on  $\COMP(\calB_R,\varepsilon,R')$ and $\COMP(\calC_{\bslambda,n_1,A},\varepsilon,R)$ for the illustrative example in Section \ref{DHKM:secexamp}.
\end{corollary}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Tractability}\label{DHKM:SecPilotTract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Besides understanding the dependence of $\COMP(\calC, \varepsilon,R)$ on $\varepsilon$, we also want to understand how $\COMP(\calC, \varepsilon,R)$ depends on the dimension of the domain of the input function.  Suppose that $f: \Omega^d \to \R$, for some $\Omega \subseteq \R$, and let $\calF_d$ denote the dependence of the input space on the dimension $d$.  
The set of functions for which our algorithms succeed, depends on the dimension, too. Thus, for the sake of brevity, we write $\calC_d$ instead of $\calC_{\bslambda,n_1,A}$ in this section. Also, $\DHKMSOL$, $\DHKMAPP$, $\DHKMCOST$, and $\COMP$ depend implicitly on the dimension, and this dependence is sometimes indicated explicitly by the subscript $d$.

\bigskip

Different dependencies of $\COMP(\calC_d, \varepsilon,R)$ on the dimension $d$ and the error tolerance $\varepsilon$ are formalized as different notions of tractability. Since 
the complexity is defined in terms of the best algorithm, tractability is a property that is inherent to the problem, not to a particular algorithm. 
We define the following notions of tractability (for further information on tractability we refer to the trilogy 
\cite{NovWoz08a}, \cite{NovWoz10a}, \cite{NovWoz12a}). Note that in contrast to 
these references we explicitly include the dependence on $R$ in our definitions. This 
dependence is natural for cones $\calC$ and might be different if $\calC$ is not a cone. 

\begin{itemize}   
\item We say that the adaptive approximation problem is strongly polynomially tractable
if and only if there are non-negative $C$, $\widetilde{p}$, and positive $\varepsilon_{\max}$, and $R_{\min}$ such that   
$$   
\COMP(\calC_d, \varepsilon,R)\le C\,R^{\widetilde{p}}\,\varepsilon^{-\widetilde{p}} \qquad \forall d\in\NN,\ \varepsilon \in (0, \varepsilon_{\max}], \ R \in [R_{\min}, \infty).
$$   
The infimum of $\widetilde{p}$ satisfying the bound above is denoted by $\widetilde{p}_*$  and is called the exponent of strong polynomial tractability.    
\newline \qquad   

\item    
We say that the problem is polynomially tractable
if and only if there are non-negative $C,\widetilde{p}$, $q$, and positive $\varepsilon_{\max}$, and $R_{\min}$ such that   
$$   
\COMP(\calC_d, \varepsilon,R)\le C\,d^{\,q}\,R^{\widetilde{p}}\,   
\varepsilon^{-{\widetilde{p}}}\qquad \forall d\in\NN,\ \varepsilon \in (0, \varepsilon_{\max}], \ R \in [R_{\min}, \infty).  
$$   
\vskip 0.5pc     

   
\item   
We say that the problem is weakly tractable iff    
$$   
\lim_{d+R\,\varepsilon^{-1}\to\infty}\   
\frac{\log\, \COMP(\calC_d, \varepsilon,R)}   
{d+R\,\varepsilon^{-1}}\,=\,0.   
$$    
\end{itemize}   
Necessary and sufficient conditions on these tractability notions will be studied 
for different types of algorithms in this section and Section \ref{DHKM:SecDecayTract}. 

We remark that, for the sake of brevity, we focus here on tractability notions that are summarized as 
algebraic tractability in the recent literature 
(see, e.g., \cite{KriWoz19}). Theoretically, one could also study exponential tractability, where 
one would essentially replace $\varepsilon^{-1}$ 
by $\log (1 + \varepsilon^{-1})$ in the previous tractability notions. A more detailed study of 
tractability will be done in a future paper.

Returning again to the example in Section \ref{DHKM:secexamp}, we have, by Corollary \ref{DHKM:cor:illex}
\begin{align*}
    \MoveEqLeft{\COMP(\calB_{R},\varepsilon,R)} 
  \le \left \lceil \left( \frac{R}{\varepsilon} \right)^{p}  \exp\left(\zeta(p r) \norm[p]{\bsw}^p  \right) \right \rceil .
\end{align*}
If $p^\dagger$ is the infimum of the $p$ for which $\norm[p]{\bsw}$ is finite, and $p^\dagger$ is finite, then we obtain strong polynomial tractability and an exponent of strong tractability that is $\widetilde{p}_* = \max(1/r,p^\dagger)$. On the other hand, if the coordinate weights are all unity,  $w_1 = w_2 = \cdots = 1$, then there are $2^d$ different $\lambda_{\bsk}$ with a value of $1$, and so $\COMP(\calB_{R},\varepsilon,R) \ge 2^d$, and the problem is not tractable.\\



Recall that we assume that 
$\lambda_{d,\bsk_1}\ge \lambda_{d,\bsk_2}\ge \cdots >0$. Let 
% \[
% n_{\COMP}(\delta,d) :=\min \left \{n\ge 0: \bignorm[\rho']{\bigl(  \lambda_{d,\bsk_i}  \bigr)_{i = n+1}^{\infty}} \,
%     \le \delta \right \} \qquad \forall \delta > 0.
% \]
\[
n_{\COMP}(\delta,d) :=\min \left \{n\ge 0: \bignorm[\rho']{\bslambda^{(n+1)}_d} \,
    \le \delta \right \} \qquad \forall \delta > 0,
\]
where as in \eqref{DHKM:taillambda} $\bslambda_d^{(n)} := (\lambda_{d,\bsk_n}, \lambda_{d,\bsk_{n+1}}, \ldots )$
From 
Equations \eqref{DHKM:PilotConeAlg_cost} and \eqref{DHKM:PilotConeAlg_comp}, we obtain that 
\begin{multline*}
     \COMP(\calC_d,\omega_{\textup{lo}} \varepsilon,R) \le n_{\COMP}(\varepsilon/R,d) \le 
        \COMP(\calC_d,\omega_{\textup{hi}} \varepsilon,R)  \\
        \forall \varepsilon \in (0, \varepsilon_{\max}], \ R \in [R_{\min}, \infty),
\end{multline*}
where the positive constants $\omega_{\textup{lo}}$ and $\omega_{\textup{hi}}$  depend on $A$, but do not depend on $d$, $\varepsilon$, or $R$.  From the equation above, it is clear that tractability depends on the behavior of $n_{\COMP}(\varepsilon/R,d)$ as $R/\varepsilon$ and $d$ tend to infinity. We would like to study under which conditions we obtain the various tractability notions defined above.

To this end, we distinguish two cases, depending on whether $\rho'$ is infinite or not. This 
distinction is useful because it allows us to relate the computational complexity of the algorithms 
considered in this chapter to the computational complexity of linear problems on certain function spaces considered in the classical literature on information-based complexity, as for example \cite{NovWoz08a}. The case $\rho'=\infty$ corresponds to the
worst-case setting, where one studies the worst performance of an algorithm over the unit ball of 
a space. The results in Theorem \ref{DHKM:thmtract1} below are indeed very similar to the results 
for the worst-case setting over balls of suitable function spaces. The case $\rho<\infty$ corresponds to the so-called average-case setting, where one 
considers the average performance over a function space equipped with a suitable measure. 
For both of these settings there exist tractability results that we will make use of here.



\paragraph*{CASE 1: $\rho'=\infty$:}

If $\rho'=\infty$, we have, due to the monotonicity of the $\lambda_{d,\bsk_i}$, 
\[
n_{\COMP}(\varepsilon/R,d)=\min \left \{n\ge 0\colon \lambda_{d,\bsk_{n+1}} \,
    \le \varepsilon/R \right \}.
\]
We then have the following theorem.

\begin{theorem} \label{DHKM:thmtract1}
Using the same notation as above, the following statements hold for the case $\rho'=\infty$.
 \begin{itemize}
  \item[1.] 
  We have strong polynomial tractability if and only if there exist $p>0$ and $i_0\in\NN$ such that
 \begin{equation}\label{DHKM:eq:condspt}
    \sup_{d\in\NN} \, \bignorm[p]{\bslambda_d^{(i_0)}} < \infty.
 \end{equation}
 Furthermore, the exponent of strong polynomial tractability is then equal to the infimum of those $p>0$ for which \eqref{DHKM:eq:condspt} holds. 
 \item[2.] 
  We have polynomial tractability if and only if there exist $p_1, p_2 \ge 0$ and $p_3, K>0$ such that
 \[
    \sup_{d\in\NN} d^{-p_1}\, \bignorm[p_3]{\bslambda_d^{(\lceil K d^{p_2} \rceil)}} < \infty.
 \]
 \item[3.] 
 We have weak tractability if and only if 
 \begin{equation}\label{DHKM:eq:condwt}
  \sup_{d\in\NN} \, \exp(-cd) \sum_{i=1}^\infty \exp\left(-c\left(\frac{1}{\lambda_{d,\bsk_i}}\right)\right) <\infty\quad \mbox{for all}\quad c>0.
 \end{equation}
\end{itemize}
\end{theorem}


\begin{proof}
If $\widetilde{\varepsilon}:=\sqrt{\varepsilon/R}$, then
$n_{\COMP}(\varepsilon/R,d)=\min \left \{n\ge 0\colon \lambda_{d,\bsk_{n+1}} \,\le \widetilde{\varepsilon}^{\,2} \right \}$. The latter expression is well studied in the context of tractability of linear problems in the worst-case setting defined on unit balls of certain spaces, and if and only if conditions on the $\lambda_{d,\bsk_i}$ for various tractability notions are known. These conditions can be found in \cite[Chapter 5]{NovWoz08a} for (strong) polynomial tractability and  \cite{WerWoz17} for weak tractability.

Since, in this chapter, we consider $\min \left \{n\ge 0\colon \lambda_{d,\bsk_{n+1}} \,\le \varepsilon/R \right \}$, and in \cite{NovWoz08a} and \cite{WerWoz17} $\varepsilon /R$ is replaced by the square of the error tolerance,
there are slight differences between the results here and those in the aforementioned references; to be more precise, the exponent of strong polynomial tractability here is, formally speaking, half of the exponent in in \cite{NovWoz08a}, and $1/\lambda_{d,\bsk_i}$ in \eqref{DHKM:eq:condwt} corresponds to $1/\sqrt{\lambda_{d,\bsk_i}}$ in \cite{WerWoz17}. 
\end{proof}

\paragraph*{CASE 2: $\rho'<\infty$:} 

In this case, letting $\widetilde{\varepsilon}:=(\varepsilon/R)^{\rho'/2}$ and 
$\widetilde{\lambda}_{d,i}:=\lambda_{d,\bsk_i}^{\rho'}$, we have 
\begin{align}
    \nonumber 
    n_{\COMP}(\varepsilon/R,d) &=\min \left \{n\ge 0\colon 
\bignorm[\rho']{\bslambda_d^{(n+1)}}^{\rho'}\,
    \le (\varepsilon/R)^{\rho'} \right \} \\
    \label{DHKM:eqaveragetract}
    & =\min \left \{n\ge 0\colon 
\bignorm[1]{\widetilde{\bslambda}_d^{(n+1)}}\,
    \le \widetilde{\varepsilon}^{\,2} \right \}.
\end{align}
However, the latter expression corresponds exactly to the 
average-case tractability (with respect to the parameters 
$\widetilde{\lambda}_{d,i}$ and $\widetilde{\varepsilon}$) defined 
on certain spaces as studied in, e.g., \cite{NovWoz08a}. 
This leads us to the following theorem.
\begin{theorem} \label{DHKM:thmtract2}
Using the same notation as above, the following statements hold for the case $\rho'<\infty$.
 \begin{itemize}
  \item[1.] 
  We have strong polynomial tractability if and only if there exist $p\in (0,1)$ and $i_0\in\NN$ such that
 \begin{equation}\label{DHKM:eq:condspt1}
    \sup_{d\in\NN} \bignorm[\rho' p]{\bslambda_d^{(i_0)}} < \infty.
 \end{equation}
 Furthermore, the exponent of strong polynomial tractability is then 
 \[
 \inf\left\{\rho'p/(1-p)\colon \mbox{$p$ satisfies \eqref{DHKM:eq:condspt1}}\right\}.
 \]
 \item[2.] 
  We have polynomial tractability if and only if there exist $p_1, p_2 \ge 0$ and $p_3\in (0,1), K>0$ such that
  \[
    \sup_{d\in\NN} d^{-p_1}\, \bignorm[\rho' p_3]{\bslambda_d^{(\lceil K d^{p_2} \rceil)}} < \infty.
 \]
 \item[3.] 
 We have weak tractability if and only if 
 \[
   \lim_{n\to\infty} (\log n)^2  \, \bignorm[1]{\bslambda_d^{(n)}} =0\quad\mbox{for all $d$},
 \]
 and there exists a function $f:[0,1/2)\to \{1,2,3,\ldots\}$ such that
\[
  \sup_{\beta\in (0,1/2]}\, \beta^{-2} \,
  \sup_{d\ge f(\beta)}\,\, \sup_{n \ge \lceil \exp (d\sqrt{b}) \rceil +1}\, \, (\log n)^2  \, \bignorm[1]{\bslambda_d^{(n)}} 
  < \infty.
\]
 \end{itemize}
\end{theorem}

\begin{proof}
  The proof of the theorem is similar to that of Theorem \ref{DHKM:thmtract1}, using \eqref{DHKM:eqaveragetract}.
\end{proof}
\begin{remark}
  Results for further tractability notions, such as quasi-polynomial tractability or $(s,t)$-weak 
  tractability, can be shown using similar arguments as above and results from \cite{KriWoz19}, \cite{NovWoz10a}, \cite{WerWoz17}, and the papers cited therein. 
\end{remark}


To be more concrete, we return to the situation where the $\lambda_{d,\bsk}$ are given 
as in \eqref{DHKM:prodwts}  one more time. We note that
$\bignorm[p]{\bslambda_d^{(i_0)}}^p<\infty$ holds if and only if  $\bignorm[p]{\bslambda_d}^p<\infty$.
We denote the $d$-dependence of the vector of coordinate weights by writing $\bsw_d:=(w_1, \ldots, w_d)$ and $\bsw_\infty = (w_1, w_2, \ldots)$.
By Lemma \ref{DHKM:prodwtsupperbound}, we have
\[
\norm[p]{\bss} \norm[p]{\bsw_d} \le \norm[p]{\bslambda_d}\le \exp\left(\frac 1p \norm[p]{\bss}^p \norm[p]{\bsw_d}^p  \right),
\]
and this estimate holds for any $d\in\NN$.
Thus, we have necessary and sufficient conditions for strong tractability.
\begin{corollary} \label{DHKM:sptexample_cor}
For the $\lambda_{d,\bsk}$ of the form \eqref{DHKM:prodwts} we have strong polynomial tractability if and only if there exists $p>0$ such that
 \begin{equation*}
%\label{DHKM:sptexample}
    \norm[p]{\bss} < \infty \text{ and } 
    \norm[p]{\bsw_\infty} < \infty.
\end{equation*}
In particular, considering example in Section \ref{DHKM:secexamp}, where $s_{k} = k^{-r}$, we have strong polynomial tractability if and only if there exists $p> 0 $ such that
\begin{equation*}
%\label{DHKM:sptexample}
   r p > 1 \text{ and } 
    \norm[p]{\bsw_\infty} < \infty.
\end{equation*}
\end{corollary}

\begin{remark}
Note that in the setting of this example, the term 
$\bignorm[p]{\bslambda_d}^p$
%$\sum_{i=1}^{\infty}\lambda_{d, \bsk_{i}}^{\eta}$ 
will usually depend exponentially on $d$ unless the 
coordinate weights, $w_\ell$, decay to zero fast enough with increasing $\ell$. Hence, we can only hope for tractability under the presence of decaying $w_\ell$. For further details on weighted approximation
problems and tractability, we refer to \cite{NovWoz08a}.
\end{remark}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tracking the Decay Rate of the Series Coefficients of the Input Function}
\label{DHKM:tracking_sec} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


From error bound \eqref{DHKM:APP_Err_Coef} it follows that the faster the $\hf(\bsk_i)$ decay, the faster $\DHKMAPP(f,n)$ converges to the solution.  Unfortunately, adaptive Algorithm \ref{DHKM:PilotConeAlg} does not adapt to the decay rate of the $\hf(\bsk_i)$ as $i \to \infty$. It simply bounds $\norm[\calF]{f}$ based on a pilot sample.  The algorithm presented in this section tracks the rate of decay of the $\hf(\bsk_i)$ and terminates sooner if the $\hf(\bsk_i)$ decay more quickly.  Similar algorithms for quasi-Monte Carlo integration are developed in \cite{HicJim16a}, \cite{JimHic16a}, and \cite{HicEtal17a}.

There is an implicit assumption in this section that function data are cheap and we can afford a large sample size.  A large sample size is required to do meaningful tracking of the decay of the series coefficients.  The previous section and the next section are more suited to the case when function data are expensive and the final sample size must be modest.

Let $\bsn = (n_j)_{j\ge 0}$ be a strictly increasing sequence of non-negative integers.  This sequence may increase geometrically or algebraically. Define the sets of wavenumbers analogously to \eqref{DHKM:KOnedef},
\begin{equation*}
   n_{-1}=0, \qquad \calK_j := \{\bsk_{n_{j-1}+1}, \ldots, \bsk_{n_j}\} \quad \text{for } j \in \N_0.
\end{equation*}
If $n_0 = 0$, then $\calK_0$ is empty.  For any $f \in \calF$, define the norms of subsets of series coefficients:
\begin{equation} \label{DHKM:SigmaDef}
\sigma_j (f):=\norm[\rho]{\biggl(\frac{\hf(\bsk)}{\lambda_{\bsk}} \biggr)_{\bsk \in \calK_j}} \qquad \text{for } j \in \N.
\end{equation}
Thus, $\norm[\calF]{f} = \norm[\rho]{\bigl(\sigma_j(f) \bigr)_{j \in \N_0}}$. 

As stated above, we would like to keep track of the rate of decay of the $\hf(\bsk_i)$. Hence, for this section, we define the cone of input functions by
\begin{equation} \label{DHKM:TrackConeDef}
  \calC_{\boldsymbol{\lambda},\bsn,a,b} : =\left\{f\in\calF \colon \sigma_{j+l} (f)\le ab^l \sigma_j (f)\ \forall j,l\in\NN\right\}.
\end{equation}
Here, $a$ and $b$ are positive reals with $b< 1 < a$. The constant $a$ is an inflation factor, and the constant $b$ defines the general rate of decay of the $\sigma_j(f)$ for $f \in  \calC_{\boldsymbol{\lambda},\bsn,a,b} $. 
We remark that knowing $\sigma_1 (f)$ would already be sufficient to identify 
a sample size that guarantees an error of at most $\varepsilon$. However, knowing $\sigma_j (f)$ for further values of $j$ will allow us to stop earlier.

Because $ab^l$ may be greater than one, we do not require the series coefficients of the solution, $\DHKMSOL(f)$, to decay monotonically. However, we expect their partial sums to decay \emph{steadily}.  The series coefficients for wavenumbers $\bsk \in \calK_0$ do not affect the definition of $\calC_{\boldsymbol{\lambda},\bsn,a,b} $ and may behave erratically.
Lemma \ref{DHKM:Key_Lem} implies that 
\begin{equation} \label{DHKM:LambdaDef}
    \norm[\tau]{\bigl(\hf(\bsk) \bigr)_{\bsk \in \calK_j}} \le \sigma_j(f) \Lambda_j, \qquad \text{where } \Lambda_j : = \norm[\rho']{\bigl(\lambda_{\bsk} \bigr)_{\bsk \in \calK_j}}.
\end{equation}
From \eqref{DHKM:SOLNorm} and \eqref{DHKM:SOLNormFinite} it follows that the norm of the solution operator is 
\begin{equation} \label{DHKM:NormLambdaFinite}
    \norm[\calF \to \calG]{\DHKMSOL} = \bignorm[\rho']{\bigl(\Lambda_j \bigr)_{j \in \N_0}} < \infty.
\end{equation}

If $f$ belongs to the $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ defined in \eqref{DHKM:TrackConeDef} and $n_0 = 0$, then 
\begin{align*}
    \norm[\calF]{f} & = \norm[\rho]{\Biggl(\,\norm[\rho]{\biggl(\frac{\hf(\bsk)}{\lambda_{\bsk}} \biggr)_{\bsk \in \calK_j}}\,\Biggr)_{j \in \N}} = \bignorm[\rho]{\bigl(\sigma_j(f) \bigr)_{j \in \N}} \\
    & \le \bignorm[\rho]{\bigl(\sigma_1(f), ab \sigma_1(f), ab^2 \sigma_1(f), \ldots \bigr)} \\
    & = \left(1 + \frac{a^\rho b^\rho}{1 - b^\rho} \right)^{1/\rho}  \norm[\rho]{\biggl(\frac{\hf(\bsk)}{\lambda_{\bsk}} \biggr)_{\bsk \in \calK_1}}.
\end{align*}
Comparing this inequality to the definition of $\calC_{\boldsymbol{\lambda},n_1,A}$ in the previous section, it can be seen that $\calC_{\boldsymbol{\lambda},\bsn,a,b}$  defined in \eqref{DHKM:TrackConeDef} is a subset of  $\calC_{\boldsymbol{\lambda},n_1,A}$ defined in \eqref{DHKM:pilot_cone} if we choose 
$A=\left[1 + a^\rho b^\rho/(1 - b^\rho) \right]^{1/\rho}$ in \eqref{DHKM:pilot_cone}.


From the expression for the error in \eqref{DHKM:APP_Err_Coef} and the definition of the cone in  \eqref{DHKM:TrackConeDef}, we can now derive a data-driven error bound for all $f \in \calC_{\boldsymbol{\lambda},\bsn,a,b} $ and $j \in \bbN$: 
\begin{align}
\nonumber
\MoveEqLeft{\norm[\calG]{\DHKMSOL(f)-\DHKMAPP(f,n_j)}} \\
\nonumber &= \norm[\tau]{\left(\hf(\bsk_i) \right)_{i = n_j+1}^\infty}
= \norm[\tau]{ \left(\norm[\tau]{\bigl(\hf(\bsk) \bigr)_{\bsk \in \calK_l}} \right)_{l=j+1}^\infty}
\\
\nonumber
& \le \norm[\tau]{ \bigl(\sigma_l(f) \Lambda_l \bigr)_{l=j+1}^\infty} \qquad \text{by \eqref{DHKM:LambdaDef}} \\
\nonumber 
&
= \norm[\tau]{ \bigl(\sigma_{j+l}(f) \Lambda_{j+l} \bigr)_{l=1}^\infty}
\\
& \le a \sigma_j(f) \norm[\tau]{ \bigl(b^l\Lambda_{j+l} \bigr)_{l=1}^\infty} =:\DHKMERRNj
 \qquad \text{by \eqref{DHKM:TrackConeDef}.}
 \label{DHKM:algoineq}
\end{align}

This upper bound depends only on the function data and the parameters defining $\calC$.  The error vanishes as $j \to \infty$ because $\sigma_j(f) \le ab^{j-1} \sigma_1(f) \to 0$ and $\Lambda_j \to 0$.  Moreover, the error bound for $\DHKMAPP(f,n_j)$ depends on $\sigma_j(f)$, whose rate of decay need not be postulated in advance.

These assumptions accommodate both the cases where the approximation converges algebraically and exponentially.  To illustrate the algebraic case, suppose that $\hf(\bsk_i)/\lambda_{\bsk_i} = \Theta(i^{-r_\Delta})$ for some positive $r_\Delta > 1/\rho$.  Here $r_\Delta$ reflects the smoothness of the input function.  For this algebraic case one would normally define $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ in terms of an exponentially increasing sequence, $(n_j)_{j\ge 0}$, e.g., $n_j = n_0 2^j$, which implies that 
\begin{align*}
    \sigma_j(f) &= \left[ \sum_{i=n_0 2^{j-1} + 1}^{n_0 2^j} \biggabs{\frac{\hf(\bsk_i)}{\lambda_{\bsk_i}}}^\rho \right]^{1/\rho}
    = \Theta\left( \left [ \sum_{i=n_0 2^{j-1} + 1}^{n_0 2^j} i^{-\rho r_\Delta} \right]^{1/\rho} \right) \\
    & =\Theta\left(  2^{-j(r_\Delta-1/\rho)} \right).
\end{align*}
Reasonable functions would satisfy 
\begin{equation*}
    C_{\lo} 2^{-j(r_\Delta-1/\rho)} \le \sigma_j(f) \le C_{\up} 2^{-j(r_\Delta-1/\rho)} 
\end{equation*}
for some constants $C_{\lo}$ and $C_{\up}$.  By reasonable we mean that the values of $\sigma_j(f)$ would not drop precipitously and then rise again as $j$ increases. Choosing $a \ge C_{\up}/C_{\lo} $  and $b \ge  2^{-(r_\Delta-1/\rho)}$ causes the cone $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ to include such functions.  Note that only the ratio of $C_{\up}$ to $C_{\lo}$ need be assumed to determine $a$, and choosing $b$ larger than necessary does not affect the order of the decay of the error bound. 

To illustrate the exponential case, suppose that $\hf(\bsk_i)/\lambda_{\bsk_i} = \Theta(\E^{-r_\Delta i})$.  For this exponential case one would normally define $\calC$ in terms of an arithmetic sequence, $(n_j)_{j\ge 0}$, e.g., $n_j = n_0 + j q$, where $q$ is a positive integer.  This implies that 
\begin{align*}
    \sigma_j(f) &= \left[ \sum_{i=n_0 + j q -q + 1}^{n_0 + j q} \biggabs{\frac{\hf(\bsk_i)}{\lambda_{\bsk_i}}}^\rho \right]^{1/\rho}
    = \Theta \left( \left [ \sum_{i=n_0 + j q -q + 1}^{n_0 + j q} \E^{- \rho r_\Delta i} \right]^{1/\rho} \right) \\
    & = \Theta \left(  \E^{-j r_{\Delta} q} \right).
\end{align*}
Analogous to the algebraic case, reasonable functions would satisfy 
    $C_{\lo} \E^{-j r_{\Delta} q} \le \sigma_j(f) \le C_{\up} \E^{-j r_{\Delta} q}$
for some constants $C_{\lo}$ and $C_{\up}$.  Choosing $a \ge C_{\up}/C_{\lo} $  and $b \ge \E^{- r_{\Delta} q}$ causes the cone $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ to include such functions.  Again, only the ratio of $C_{\up}$ to $C_{\lo}$ need be assumed to determine $a$, and choosing $b$ larger than necessary does not affect the order of the decay of the error bound.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Adaptive Algorithm and Its Information Cost} \label{DHKM:SecAdapAlgTrackDecay}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The data-driven error bound in \eqref{DHKM:algoineq} forms the basis for an adaptive Algorithm \ref{DHKM:TrackConeAlg}, which solves our problem for input functions in the cone $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ defined in \eqref{DHKM:TrackConeDef}.  The following theorem establishes its viability and information cost. In deriving upper bounds on the information cost and lower bounds on the complexity, we may sacrifice tightness for simplicity.

\begin{algorithm}
	\caption{Adaptive ALG for a Cone of Input Functions Tracking the Series Coefficient Decay Rate \label{DHKM:TrackConeAlg}}
	\begin{algorithmic}
	\PARAM the Banach spaces $\calF$ and $\calG$, including the weights $\bslambda$; a strictly increasing sequence of non-negative integers, $(n_j)_{j\ge 0}$; an inflation factor, $a$; the general decay rate, $b$; $\DHKMAPP$ satisfying \eqref{DHKM:APP_Err_Coef}
		\INPUT a black-box function, $f$; an absolute error tolerance,
		$\varepsilon>0$

\Ensure Error criterion \eqref{DHKM:err_crit} for  the cone defined in \eqref{DHKM:TrackConeDef}

\State Let $j \leftarrow 0$
\Repeat

\State Let $j \leftarrow j + 1$

\State Compute $\DHKMERRNj$ as defined in \eqref{DHKM:algoineq}

\Until $\DHKMERRNj \le \varepsilon$

\RETURN $\DHKMALG(f,\varepsilon) = \DHKMAPP(f,n_{j})$
\end{algorithmic}
\end{algorithm}



\begin{theorem}\label{DHKM:TrackConeCompCost}
Algorithm \ref{DHKM:TrackConeAlg} yields an answer satisfying absolute error criterion \eqref{DHKM:err_crit}, i.e., $\DHKMALG \in \calA(\calC_{\boldsymbol{\lambda},\bsn,a,b})$ for $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ defined in \eqref{DHKM:TrackConeDef}.  The information cost is $\DHKMCOST(\DHKMALG,f,\varepsilon)=n_{j^*}$, where $j^*$ is defined implicitly as
\begin{equation} \label{DHKM:EqTrackConejstar}
j^* = \min\left \{ j \in \bbN : \DHKMERRNj \le \varepsilon  \right\}.
\end{equation}
Moreover, $\DHKMCOST(\DHKMALG,\calC_{\boldsymbol{\lambda},\bsn,a,b},\varepsilon,R) \le n_{j^\dagger}$, where $j^\dagger$ is defined as follows:
\begin{equation} \label{DHKM:TractConejdagger}
j^\dagger = \min \left \{j \in \bbN :   \norm[\tau]{ \bigl(b^{l}\Lambda_{j+l} \bigr)_{l=1}^\infty}
\le  \frac{b\varepsilon}{Ra^2}\right\}.
\end{equation}
\end{theorem}

\begin{proof}
The value of $j^*$ in \eqref{DHKM:EqTrackConejstar} follows directly from the error criterion. The success of the algorithm follows from the error bound in \eqref{DHKM:algoineq}.

For the remainder of the proof consider $R$ and $\varepsilon$ to be fixed.  For any $f \in  \calC_{\boldsymbol{\lambda},\bsn,a,b} \cap \calB_R$ and for any $j^\dagger$ defined  as in \eqref{DHKM:TractConejdagger}, it follows that
\begin{align*}
R &\ge \norm[\calF]{f} = \norm[\rho]{\left(\frac{\hf(\bsk)}{\lambda_{\bsk}} \right)_{\bsk \in \bbK}}
 \ge \norm[\rho]{\left(\sigma_j(f)\right)_{j=1}^{j^\dagger}}  
 \qquad \text{by \eqref{DHKM:SigmaDef} } \\
& \ge \sigma_1(f) \ge a^{-1}b^{1-j^\dagger}\sigma_{j^\dagger}(f) \quad \text{by  \eqref{DHKM:TrackConeDef}}\\
& \ge \sigma_{j^\dagger}(f)\,\frac{Ra}{\varepsilon} \norm[\tau]{ \bigl(b^l \Lambda_{j^\dagger+l} \bigr)_{l=1}^\infty}
\qquad \text{by the definition of } j^\dagger \text{ in \eqref{DHKM:TractConejdagger}} \\
& = \frac{R}{\varepsilon} \DHKMERRNjd\, .
\end{align*}
From this last inequality, it follows that $j^\dagger \ge j^*$.
\end{proof} 

Although Algorithm \ref{DHKM:TrackConeAlg} tracks the decay rate of the $\hf(\bsk_i)$, the information cost bound and complexity bound in the theorem above do not reflect different decay rates of the $\hf(\bsk_i)$. That is a subject for future investigation.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bounds on the Information Cost for $\rho = \tau$, $\rho' = \infty$}\label{DHKM:SecDecayRhoEqTau}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We again turn to the special case considered in Section \ref{DHKM:revisexamp}, where $\rho = \tau$ and $\rho' = \infty$.  Furthermore, we consider a geometric progression of the $n_j$, namely, $\bsn = \bigl (n_02^j \bigr)_{j \in \bbN_0}$, so that
\[
\calK_0 = \{\bsk_{1}, \ldots, \bsk_{n_0}\}, \qquad \calK_j = \{\bsk_{n_0 2^{j-1}+1}, \ldots, \bsk_{n_02^j}\} \quad \text{for } j \in \N.
\]
Our goal, as in Section \ref{DHKM:revisexamp}, is to derive upper and lower bounds on the information cost of Algorithm \ref{DHKM:TrackConeAlg}. For the illustrative example in Section \ref{DHKM:secexamp} with weights defined in \eqref{DHKM:IllExWts}, the sets $\calK_j$ look roughly like hyperbolic slices of $\N_0^d$.

From Lemma \ref{DHKM:lambdineq} it follows that 
\begin{equation*}
    \Lambda_j = \norm[\infty]{\bigl(\lambda_{\bsk} \bigr)_{\bsk \in \calK_j}} = \lambda_{\bsk_{n_02^{j-1}+1}}\le \frac{\norm[p]{\bslambda}}{n_0^{1/p} 2^{(j-1)/p}} \qquad \forall j \in \bbN.
\end{equation*}
The key term in the upper bound on the information cost in \eqref{DHKM:TractConejdagger} is
\begin{align*}
\norm[\rho]{ \bigl(b^{l}\Lambda_{j+l} \bigr)_{l=1}^\infty}^\rho
 & =  \sum_{l=1}^\infty
( b^{l}\Lambda_{j+l})^\rho \\
& \le \sum_{l=1}^\infty  
 \frac{b^{l\rho} \norm[p]{\bslambda}^\rho }{ n_0^{\rho/p} 2^{(j+l-1)\rho/p}} 
=  
 \frac{b^{\rho} \norm[p]{\bslambda}^\rho }{ n_0^{\rho/p} 2^{j\rho/p} (1 - b^{\rho}/2^{\rho/p})}, \\
\norm[\rho]{ \bigl(b^{l}\Lambda_{j+l} \bigr)_{l=1}^\infty}
 & \le  
 \frac{b \norm[p]{\bslambda} }{ n_0^{1/p} 2^{j/p} (1 - b^{\rho}/2^{\rho/p})^{1/\rho}}.
\end{align*}
From \eqref{DHKM:TractConejdagger} in Theorem \ref{DHKM:TrackConeCompCost} it follows that the cost of Algorithm \ref{DHKM:TrackConeAlg} has an upper bound of $\DHKMCOST(\DHKMALG,\calC_{\bslambda,\bsn,a,b},\varepsilon,R) \le n_j = n_0 2^j$ for any $j$ satisfying 
\begin{align*}
    \frac{b \norm[p]{\bslambda} }{ n_0^{1/p} 2^{j/p} (1 - b^{\rho}/2^{\rho/p})^{1/\rho}} &\le \frac{b\varepsilon}{R a^2}, \\
   \left(\frac{ R a^{2} \norm[p]{\bslambda} }{\varepsilon (1 - b^{\rho}/2^{\rho/p})^{1/\rho}} \right)^p & \le n_0 2^{j}.
\end{align*}
This argument leads to the following upper bound on the information cost, which is similar to Theorem \ref{DHKM:thm:costbdspilot}.  Applying Lemma \ref{DHKM:prodwtsupperbound} yields a result analogous to Corollary \ref{DHKM:cor:illex}.

\begin{theorem}
\label{DHKM:thm:TrackConeExUpBd}
If the elements of $\bslambda$ decay fast enough so that $\norm[p]{\bslambda} < \infty$ and $\rho'=\infty$, then the information cost of Algorithm \ref{DHKM:TrackConeAlg} is bounded above by
\begin{multline*}
\DHKMCOST(\DHKMALG,\calC_{\bslambda,\bsn,a,b},\varepsilon, R) \\
    \le 
    \min \left \{n_0 2^j , \ j \in \N_0 : 
    n_0 2^j \ge \left(\frac{ R a^{2} \norm[p]{\bslambda} }{\varepsilon (1 - b^{\rho}/2^{\rho/p})^{1/\rho}} \right)^p
    \right\}.
    \end{multline*}
For the function spaces defined in the illustrative example in Section \ref{DHKM:secexamp}, for all $p > 1/r$:
\begin{multline*}
 \DHKMCOST(\DHKMALG,\calC_{\bslambda,\bsn,a,b},\varepsilon, R) \\
   \le \min \left \{n_0 2^j , \ j \in \N_0 : 
    n_0 2^j \ge \left(\frac{ R a^{2}\exp\left( \zeta(pr) \norm[p]{\bsw}^p  \right)  }{\varepsilon (1 - b^{\rho}/2^{\rho/p})^{1/\rho}} \right)^p \right \}.
    \end{multline*}
Thus, the information cost in this case is nearly $\calO(\bigl(R/\varepsilon\bigr)^{1/r})$, with a larger $r$ yielding a lower asymptotic information cost.
\end{theorem}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Essential Optimality of the Algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To establish the essential optimality of Algorithm \ref{DHKM:TrackConeAlg} requires some additional, reasonable assumptions on the sequences $(n_j)_{j \in \N_0}$ and $\bigl(\sigma_j(f) \bigr)_{j \in \N_0}$.  Recall from \eqref{DHKM:NormLambdaFinite} that $\bigl(\Lambda_j \bigr)_{j \in \N_0}$ has a finite $\rho'$ norm.  We require that the $\Lambda_j$ must decay steadily with $j$:
\begin{equation} \label{DHKM:LambdaDecayCond}
    \alpha^{-1} \beta^r \Lambda_j \le \Lambda_{j+r} \le \alpha \gamma^r \Lambda_j  \quad \forall j,r \in \N_0, \qquad \text{for some } \beta, \gamma < 1 \le \alpha.
\end{equation}
We also assume that the ratio of the largest to smallest $\lambda_{\bsk}$ in a group is bounded above:
\begin{equation} \label{DHKM:MinMaxCond}
    \sup_{j \in \N} \frac{\lambda_{\bsk_{n_{j-1}+1}}}{\lambda_{\bsk_{n_{j}}}} \le S_1 < \infty.
\end{equation}
For the illustrative choices of $(n_j)_{j \in \N_0}$ and $\bigl(\bsk_i \bigr)_{i \in \N}$ preceding Section \ref{DHKM:SecAdapAlgTrackDecay} this assumption holds.  Let $\DHKMcard(\cdot)$ denote the cardinality of a set. We assume that if $\calJ$ is an arbitrary set of wavenumbers with $\DHKMcard(\calJ) \le n_j$, then there exists some $l \le j+1$ for which $\calK_l \setminus \calJ$ retains some significant fraction of the original $\calK_l$ elements: 
\begin{equation} \label{DHKM:PropCond}
     \inf_{j \in \N} \ \min_{\calJ \subset \bbK \, : \, \DHKMcard(\calJ) \le n_j} \ \max_{0 \le l \le j+1} \frac{\DHKMcard(\calK_l \setminus \calJ)}{\DHKMcard(\calK_l)} \ge S_2 > 0.
\end{equation}
Again, for the illustrative choices of $(n_j)_{j \in \N_0}$ and $\bigl(\bsk_i \bigr)_{i \in \N}$ preceding Section \ref{DHKM:SecAdapAlgTrackDecay} this assumption holds.

The following theorem establishes a lower bound on the complexity of our problem for input functions in $\calC_{\boldsymbol{\lambda},\bsn,a,b}$. The theorem after that shows that the cost of our algorithm as given in Theorem \ref{DHKM:TrackConeCompCost} is essentially no worse than this lower bound.

\begin{theorem} \label{DHKM:TractConeLowBdComp}
A lower bound on the complexity of the linear problem is
\begin{align*}
 %\label{compbdA}
&\COMP(\calC_{\boldsymbol{\lambda},\bsn,a,b},\varepsilon,R) > n_{j^\ddagger}, 
\intertext{where}
%\label{compbdB}
j^\ddagger & = \max \left \{ j \in \bbN :  b^{j+1} \Lambda_{j+1}    > 
 \frac{2a\alpha \varepsilon}{R(a-1)(1 - b^\rho)^{1/\rho}}  \left[1 + \left(\frac 1 {S_2} -1 \right) S_1^\rho \right]^{1/\rho}
\right \}.
\end{align*}
\end{theorem}

\begin{proof}

As in the proof of Theorem \ref{DHKM:PilotCostThm} we consider fixed and arbitrary R and $\varepsilon$.
We proceed by carefully constructing the test input functions, $f_1$ and $f_{\pm} = f_1 \pm f_2$, lying in $\calC_{\boldsymbol{\lambda},\bsn,a,b}\cap \calB_{R}$, which yield the same approximate solution but different true solutions.  This leads to a lower bound on $\COMP(\calC_{\boldsymbol{\lambda},\bsn,a,b},\varepsilon,R)$. The proof is provided for $\rho' < \infty$.  The proof for $\rho' = \infty$ is similar.

The first test function $f_1 \in \calC_{\boldsymbol{\lambda},\bsn,a,b}$ is defined in terms of its series coefficients---inspired by Lemma \ref{DHKM:Key_Lem}---as
\begin{align}
\nonumber
f_1 &= f_{10} + f_{11} +  \cdots, \qquad
\hf_{1j}(\bsk) := \begin{cases}
\displaystyle
\frac{c_1 b^{j} \lambda_{\bsk}^{\rho'/\rho+1}}{\Lambda_j^{\rho'/\rho}},  & \bsk \in \calK_j,
\\
0, & \bsk \notin \calK_j,
\end{cases}
\\
\nonumber
c_1 &:=  \frac{R(a+1)(1 - b^\rho)^{1/\rho}}{2a}.
\end{align}
It can be verified that the test function lies both in $\calB_{R}$ and in $\calC_{\boldsymbol{\lambda},\bsn,a,b}$:
\begin{align}
\nonumber
\sigma_j(f_1) & = \norm[\rho]{\biggl(\frac{\hf_{1j}(\bsk)}{\lambda_{\bsk}} \biggr)_{\bsk \in \calK_j}} 
= c_1 b^j, \qquad j \in \N_0,\\
\nonumber
\norm[\calF]{f_1} &= \norm[\rho]{\bigl( \sigma_j(f) \bigr)_{j \in \N_0} } 
=  \frac{c_1}{(1 - b^\rho)^{1/\rho}} = \frac{R(a+1)}{2a} \le R,
\\
\nonumber
\sigma_{j+r}(f_1) &= 
b^{l} \sigma_j(f_1) \le a b^l \sigma_j(f_1), \qquad j,l \in \N_0.
\end{align}

Now let $\DHKMALG'$ be an arbitrary algorithm in $\calA(\calC_{\boldsymbol{\lambda},\bsn,a,b})$, and suppose that $\DHKMALG'(f_1,\varepsilon)$ samples $f_1(\bsk)$ for $\bsk \in \calJ$.  Let $\tcalK_j = \calK_j \setminus \calJ$ for all non-negative integers $j$. Construct the function $f_2$, having zero coefficients for $\bsk \in \calJ$, but otherwise looking like $f_1$:
\begin{align}
\nonumber
f_2 &= f_{20} + f_{21} +  \cdots, \qquad \hf_{2j}(\bsk) := \begin{cases}
\displaystyle
\frac{c_2 b^{j} \lambda_{\bsk}^{\rho'/\rho+1}}{\tLambda_j^{\rho'/\rho}},  
& \bsk \in \tcalK_j,
\\
0, & \text{otherwise},
\end{cases}
\\
\nonumber
c_2 &:= \frac{R(a-1)(1 - b^\rho)^{1/\rho}}{2a}, \qquad
\tLambda_j := \norm[\rho']{\bigl(\lambda_\bsk \bigr)_{\bsk \in \tcalK_j}} \le \Lambda_j, \\
\nonumber
\sigma_j(f_2) & = \norm[\rho]{\biggl(\frac{\hf_{2j}(\bsk)}{\lambda_{\bsk}} \biggr)_{\bsk \in \tcalK_j}} 
= \begin{cases} c_2 b^j, & \tcalK_j \ne \emptyset, \\
0, & \tcalK_j = \emptyset, 
\end{cases}
\qquad j \in \N_0, \\
\nonumber 
\norm[\calF]{f_2} &= \norm[\rho]{\bigl( \sigma_j(f_{2}) \bigr)_{j \in \N_0} } 
\le \frac{c_2}{(1 - b^\rho)^{1/\rho}} = \frac{R(a - 1)}{2a}\le R, \\
\nonumber 
\norm[\calG]{\DHKMSOL(f_{2j})} &= \sigma_j(f_{2j}) \tLambda_j = 
c_2 b^{j} \tLambda_j, \qquad j \in \N_0, \\
\norm[\calG]{\DHKMSOL(f_2)} & = \norm[\tau]{\bigl(c_2 b^{j} \tLambda_j \bigr)_{j \in \N_0}}
= \frac{R(a-1)(1 - b^\rho)^{1/\rho}}{2a} \norm[\tau]{\bigl(b^{j} \tLambda_j \bigr)_{j \in \N_0}}.
\label{DHKM:SOLftwo}
\end{align}

Furthermore, define $f_{\pm} = f_1 \pm f_2$.
It can be verified that $f_{\pm}$ also lie both in $\calB_{R}$ and in $\calC_{\boldsymbol{\lambda},\bsn,a,b}$:
\begin{align}
\nonumber
\norm[\calF]{f_\pm} &\le \norm[\calF]{f_1} + \norm[\calF]{f_2} \le \frac{c_1 + c_2}{(1 - b^\rho)^{1/\rho}} = R,
\\
\nonumber
\sigma_j(f_\pm) & \ge \sigma_j(f_1) - \sigma_j(f_2) \ge
\left(c_1 - c_2 \right) b^{j} = \frac{R(1 - b^\rho)^{1/\rho}b^{j}}{a},  \qquad j \in \N_0,
\\
\nonumber
\sigma_{j+l}(f_\pm) & \le \sigma_{j+l}(f_1) + \sigma_{j+l}(f_2) \le 
(c_1+c_2) b^{j+l} 
\\
\nonumber
& =  R(1 - b^\rho)^{1/\rho}b^{j+l}
\le a b^l \sigma_j(f_\pm),  \qquad j, l \in \N_0.
\end{align}

Since $\hf_2(\bsk) = 0$ for $\bsk \in \calJ$, it follows that $\DHKMALG'(f_\pm,\varepsilon) = \DHKMALG'(f_1,\varepsilon)$.  But, even though the two test functions $f_\pm$ lead to the same approximate solution, they have different true solutions.  In particular,
\begin{align}
\nonumber
\varepsilon &\ge \max \bigl\{\norm[\calG]{\DHKMSOL(f_+) - \DHKMALG'(f_+,\varepsilon)}, \norm[\calG]{\DHKMSOL(f_-) - \DHKMALG'(f_-,\varepsilon)} \bigr\} \\
\nonumber
&\ge \frac 12 \bigl[\norm[\calG]{\DHKMSOL(f_+) - \DHKMALG(f_1,\varepsilon)} + \norm[\calG]{\DHKMSOL(f_-) - \DHKMALG'(f_1,\varepsilon)}  \bigr] \\
\nonumber
&\qquad \qquad \text{since } \DHKMALG'(f_\pm,\varepsilon) = \DHKMALG'(f_1,\varepsilon) \\
\nonumber
&\ge \frac 12 \norm[\calG]{\DHKMSOL(f_+) - \DHKMSOL(f_-)} \quad \text{by the triangle inequality}\\
\nonumber
&\ge \frac 12 \norm[\calG]{\DHKMSOL(f_+ - f_-)} \quad \text{since $\DHKMSOL$ is linear}\\
&= \norm[\calG]{\DHKMSOL(f_2)} 
= \frac{R(a-1)(1 - b^\rho)^{1/\rho}}{2a} \norm[\tau]{\bigl(b^{j} \tLambda_j \bigr)_{j \in \N_0}}
\qquad 
\text{by \eqref{DHKM:SOLftwo}.}
\label{DHKM:eps_LBA}
\end{align}

Suppose that $\DHKMcard(\calJ) = \DHKMCOST(\DHKMALG',f_{\pm},\varepsilon) \le n_{j^{\star}}$.  Then by condition \eqref{DHKM:PropCond}, there exists an $l^\star \le j^\star+1$ where $\DHKMcard(\tcalK_{l^\star}) \ge S_2 \DHKMcard(\calK_{l^\star})$.  
This implies a lower bound on $\tLambda_{l^\star}$.  Let $m = n_{l^\star} - n_{l^\star-1} = \DHKMcard(\calK_{l^\star})$.  Then, $m_{\inc} = \lceil S_2 m \rceil \ge S_2 m$ is a lower bound on  $\DHKMcard(\tcalK_{l^\star})$, and $m_{\out} = m - m_{\inc} \le (1 - S_2) m$ is an upper bound on $\DHKMcard(\calK_{l^\star} \setminus \tcalK_{l^\star})$.  Moreover, 

\begin{align*}
    \Lambda_{l^\star}^\rho & = \sum_{i \in \calK_{l^\star}} \lambda_{\bsk_i}^{\rho} =  \tLambda_{l^\star}^\rho + \sum_{i \in \calK_{l^\star} \setminus \tcalK_{l^\star}} \lambda_{\bsk_i}^{\rho}
    \\
    &\le  \tLambda_{l^\star}^\rho + m_{\out} \lambda_{\bsk_{n_{l^\star -1}+1}}^\rho \qquad \text{by the ordering of the } \lambda_{\bsk_i}\\
    &\le  \tLambda_{l^\star}^\rho + m_{\out} S_1^\rho \lambda_{\bsk_{n_{l^\star}}}^\rho \qquad \text{by \eqref{DHKM:MinMaxCond}}\\
    & \le \tLambda_{l^\star}^\rho + \frac{m_{\out}}{m_{\inc}} S_1^\rho \tLambda_{l^\star}^\rho \qquad \text{by the definition of } \tLambda_{l^\star}\\
    & \le \left[1 + \left(\frac 1 {S_2} -1 \right) S_1^\rho \right] \tLambda_{l^\star}^\rho \qquad \text{by the bounds on } m_{\inc} \text{ and } m_{\out} 
    \\
    & \le \left[1 + \left(\frac 1 {S_2} -1 \right) S_1^\rho \right] b^{-\rho l^\star} \norm[\tau]{\bigl(b^{j} \tLambda_j \bigr)_{j \in \N_0}}^\rho\, .
\end{align*}

Returning to \eqref{DHKM:eps_LBA}, the above inequality  implies that
\begin{equation*}
    \varepsilon 
\ge  \frac{R(a-1)(1 - b^\rho)^{1/\rho}}{2a} \left[1 + \left(\frac 1 {S_2} -1 \right) S_1^\rho \right]^{-1/\rho} b^{l^\star} \Lambda_{l^\star}.
\end{equation*}
Since $l^\star \le j^{\star}+1$ it follows that $ b^{l^\star} \ge b^{j^\star+1}$ and from condition \eqref{DHKM:LambdaDecayCond} it follows that $\Lambda_{l^\star} \ge \Lambda_{j^\star+1}/\alpha$.  Thus,
\begin{equation*}
    \varepsilon 
\ge  \frac{R(a-1)(1 - b^\rho)^{1/\rho}}{2a\alpha} \left[1 + \left(\frac 1 {S_2} -1 \right) S_1^\rho \right]^{-1/\rho} b^{j^\star+1} \Lambda_{j^\star+1}.
\end{equation*}
If any algorithm satisfies the error tolerance $\varepsilon$ for all input functions in $\calC_{\boldsymbol{\lambda},\bsn,a,b} \cap \calB_R$ and has information cost no greater than $n_{j^\star}$, then $j^\star$ must satisfy the above inequality.  By contrast, if the above inequality is violated for any $j^\star$, then the information cost of the successful algorithm must be greater than $n_{j^\star}$.  This completes the proof.
\end{proof}

\begin{theorem}
\label{DHKM:TrackConeAlgOptThm}
Adaptive Algorithm \ref{DHKM:TrackConeAlg} is essentially optimal for the cone of input functions defined in \eqref{DHKM:TrackConeDef}.
\end{theorem}
\begin{proof}
Let $j^\dagger(\varepsilon)$ be defined as in \eqref{DHKM:TractConejdagger}, with the $\varepsilon$ dependence made explicit.  Choose $\varepsilon_{\max}$ and $R_{\min}$ in \eqref{DHKM:EssentialOpt} such that $j^\dagger(\varepsilon) \ge 2$.  This definition implies that

\begin{align*}
    b^{j^\dagger(\varepsilon)} \Lambda_{j^\dagger(\varepsilon) } 
   & = \frac{[1 - (\gamma b)^\tau]^{1/\tau}}{\alpha}
   \norm[\tau]{ \bigl(b^{j^\dagger(\varepsilon)-1+r} \alpha \gamma^{r-1} \Lambda_{j^\dagger(\varepsilon)} \bigr)_{r=1}^\infty}
    \\
    & \ge \frac{[1 - (\gamma b)^\tau]^{1/\tau}}{\alpha}  \norm[\tau]{ \bigl(b^{j^\dagger(\varepsilon)-1+r}\Lambda_{j^\dagger(\varepsilon)-1+r} \bigr)_{r=1}^\infty} \qquad \text{by \eqref{DHKM:LambdaDecayCond}} 
    \\
    &
    > \frac{b [1 - (\gamma b)^\tau]^{1/\tau} \varepsilon}{Ra^2 \alpha} \left( \frac{1 - b^{\rho(j^\dagger(\varepsilon)-1)}}{1 - b^\rho} \right)^{1/\rho} \qquad \text{by \eqref{DHKM:TractConejdagger}}
    \\
    &
    \ge \frac{b [1 - (\gamma b)^\tau]^{1/\tau} \varepsilon}{Ra^2 \alpha} \qquad \text{since } j^\dagger(\varepsilon) \ge 2
    \\
    & =   \frac{\alpha^2}{(b\beta)^2} \times \frac{2a \alpha \omega \varepsilon}{R(a-1)(1 - b^\rho)^{1/\rho}}  \left[1 + \left(\frac 1 {S_2} -1 \right) S_1^\rho \right]^{1/\rho}
    \\
    \intertext{where }
   \omega  & = \frac{(a-1)b^3 \beta^2 (1 - b^\rho)^{1/\rho} [1 - (\gamma b)^\tau]^{1/\tau}}{2a^3 \alpha^4 } \left[1 + \left(\frac 1 {S_2} -1 \right) S_1^\rho \right]^{-1/\rho}.
\end{align*}

Making the $\varepsilon$ dependence explicit in the definition of $j^\ddagger(\varepsilon)$ in Theorem \ref{DHKM:TractConeLowBdComp} it follows from the above inequality and \eqref{DHKM:LambdaDecayCond} that
\begin{equation*}
    b^{j^\dagger(\varepsilon)} \Lambda_{j^\dagger(\varepsilon) } 
     > \frac{\alpha^2}{(b\beta)^2} b^{j^\ddagger(\omega\varepsilon)+2} \Lambda_{j^\ddagger(\omega \varepsilon) + 2 } 
    \ge \alpha b^{j^\ddagger(\omega\varepsilon)} \Lambda_{j^\ddagger(\omega \varepsilon)}.
\end{equation*}
If $j^{\dagger}(\varepsilon) \ge j^{\ddagger}(\omega \varepsilon)$, then \eqref{DHKM:LambdaDecayCond} implies that 
\[
 b^{j^\dagger(\varepsilon)} \Lambda_{j^\dagger(\varepsilon) } \le \alpha (\gamma b)^{j^{\dagger}(\varepsilon) - j^{\ddagger}(\omega \varepsilon)} b^{j^{\ddagger}(\omega \varepsilon) } \Lambda_{j^\ddagger(\omega \varepsilon) } \le \alpha b^{j^{\ddagger}(\omega \varepsilon) } \Lambda_{j^\ddagger(\omega \varepsilon) }.
\]
But, this contradicts the above inequality.  Thus, $j^\dagger(\varepsilon) < j^\ddagger(\omega \varepsilon)$, and so
\[
\DHKMCOST(\DHKMALG,\calC_{\boldsymbol{\lambda},\bsn,a,b},\varepsilon,R) \le n_{j^\dagger(\varepsilon)} < n_{j^\ddagger(\omega \varepsilon)} < \COMP(\calC_{\boldsymbol{\lambda},\bsn,a,b},\omega \varepsilon,R).
\]
Thus,  Algorithm \ref{DHKM:TrackConeAlg} is essentially optimal.
\end{proof}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Tractability}\label{DHKM:SecDecayTract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



We again would like to study tractability. As it turns out, by using the relation 
between the cones defined in \eqref{DHKM:pilot_cone} and \eqref{DHKM:TrackConeDef}, respectively, we 
easily obtain sufficient conditions for tractability. 

\begin{theorem} \label{DHKM:thmtract3}
The respective conditions presented in Theorem \ref{DHKM:thmtract1} for the case where $\rho'=\infty$ and 
in Theorem \ref{DHKM:thmtract2} for the case where $\rho'<\infty$ are sufficient for strong polynomial, polynomial, and weak tractability of the approximation problem defined on cones as in \eqref{DHKM:TrackConeDef}.
\end{theorem}
\begin{proof}
As pointed out above, $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ defined in \eqref{DHKM:TrackConeDef} is a subset of  $\calC_{\boldsymbol{\lambda},n_1,A}$ defined in \eqref{DHKM:pilot_cone}, by choosing $A=\left(1 + \frac{a^\rho b^\rho}{1 - b^\rho} \right)^{1/\rho}$ in \eqref{DHKM:pilot_cone}. This means that the approximation problem on  $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ defined in \eqref{DHKM:TrackConeDef} is essentially (i.e., up to constants depending on $A,a,b$ and $\rho$) no harder than the same problem on $\calC_{\boldsymbol{\lambda},\bsn,a,b}$ defined in \eqref{DHKM:pilot_cone}. This, however, implies that all sufficient conditions in Theorem \ref{DHKM:thmtract1} are also sufficient in the case considered in Theorem \ref{DHKM:thmtract3}.
\end{proof}

Theorem \ref{DHKM:thmtract3} yields sufficient conditions for the tractability notions considered 
here. A general result for necessary conditions seems to be more difficult to obtain and is left open for future research.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Inferring Coordinate and Smoothness Importance} \label{DHKM:smoothimportance_sec}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In Sections \ref{DHKM:pilot_sec} and \ref{DHKM:tracking_sec}, the weights $\bslambda = (\lambda_{\bsk_1}, \lambda_{\bsk_2}, \ldots )$, which appear in the definition of the cone of inputs, $\calC_{\bslambda,n_1,A}$ and $\calC_{\bslambda,\bsn,a,b}$, are taken as given and fixed.  One may assume the form suggested in \eqref{DHKM:prodwts}, which defines $\bslambda$ in terms of coordinate weights, $\bsw$, and smoothness weights, $\bss$.  However, practically speaking it may be difficult to know a priori suitable values for these weights.
This section explores a situation where the initial data collected for the input function data can be used to learn $\bsw$ and $\bss$, inferring which input variables in $f$ may be more important and the smoothness of the function.  We focus on inferring the $\bslambda$ defining the cone $\calC_{\bslambda,n_1,A}$ in Section \ref{DHKM:pilot_sec}.  

This section is motivated by situations where the relative importance of the $d$ input variables of the function is not known from physical considerations. We also envision situations where the cost of function data is large, e.g., the result of an expensive computer simulation.  Thus, we are not concerned with the cost of the algorithm beyond the information cost, which we hope to limit to $\calO(d)$.

\subsection{Product, Order and Smoothness Dependent (POSD) Weights}
The $u_{\bsk}$ and the $\lambda_{\bsk}$ in this section are defined as 
\begin{equation}
u_\bsk = \prod_{\ell = 1}^d \tu_{k_\ell}, \quad 
\lambda_{\bsk} = \Gamma_{\|\bsk\|_0} \prod_{\substack{\ell=1\\ k_\ell>0}}^d w_\ell s_{k_\ell}, \quad \Gamma_0 = s_1 = 1, \quad \bsk \in \mathbb{N}_0^d,
\label{DHKM:posdeq}
\end{equation}
where $\bsw = (w_\ell)_{\ell=1}^d$ is the vector of coordinate weights, $\bss = (s_k)_{k=1}^\infty$ is the vector of smoothness weights,  $\boldsymbol{\Gamma} = (\Gamma_m)_{m=1}^d$ is the vector of \emph{order weights}, and $\norm[0]{\bsk}$ denotes the number of nonzero elements of $\bsk$. This is a generalization of the form for $\bslambda$ given by \eqref{DHKM:prodwts}. The intuition behind these weights is as follows: 
\begin{itemize}
    \item Coordinate weights quantify the importance for the $d$ input variables in $f$.
    \item Smoothness weights quantify the importance of the $\tu_k$.  E.g., if the $\tu_k$ are polynomials of degree $k$ as in Section \ref{DHKM:secexamp}, then the faster the $s_k$ decay, the smoother $f$ is.  
    \item Order weights quantify the importance of effects with different orders; $\bsk$ having one nonzero element corresponds to a first-order or main effect, $\bsk$ having two nonzero elements corresponds to a second-order (interaction) effect (e.g., first-order, second-order).
\end{itemize} \ \vspace{-4ex}

This parametrization is motivated by several guiding principles from the experimental design literature \citep{WuHam2009}, which are briefly described below.  In statistical parlance, the terms $\hf(\bsk) u_{\bsk}$ are effects.
\begin{itemize}
\item \emph{Effect sparsity} assumes that only a small number of coordinates in $f$ are important. In \eqref{DHKM:posdeq}, this sparsity means that only a small number of product weights $\bsw$ are large.  This principle arises in the sufficient condition for strong tractability in Corollary \ref{DHKM:sptexample_cor}.
\item \emph{Effect heredity} assumes that lower-order effects are more important than higher-order effects. E.g., $\lambda_{(1,0, 0,\ldots, 0)}$ should be larger than $\lambda_{(1, 1, 0, \ldots, 0)}$. In \eqref{DHKM:posdeq}, this heredity can be enforced by assuming that the order weights $\Gamma_{m}$ decrease with $m$. 
\item \emph{Effect hierarchy} assumes that an effect is active \emph{only} when all its component effects are active. For example, $\lambda_{(1, 1, 0, \ldots, 0)} > 0$ only when $\lambda_{(1, 0, 0, \ldots, 0)}$ and $\lambda_{(0, 1, 0, \ldots, 0)}$ are both nonzero. This hierarchy is implicitly enforced by the product structure of the weights in \eqref{DHKM:posdeq}.
\item \emph{Effect smoothness} assumes that lower-degree effects are more important than higher-degree effects. For example, when the $(\tu_k)_{k \in \mathbb{N}_0}$ are polynomials, this means that linear effects are more important than quadratic effects, which are in turn more significant than cubic effects, and so on. Effect smoothness can be imposed by assuming $\bss$ to be a decreasing sequence. 
\end{itemize} 
\vspace{-3ex}
These principles will guide the inference of weights $\bslambda$ (and its corresponding cone of inputs $\calC_{\bslambda,n_1,A}$) from initial data.

\hspace{\parindent} The $\lambda_{\bsk}$ defined in \eqref{DHKM:posdeq} are called product, order and smoothness dependent (POSD) weights.  From a quasi-Monte Carlo (QMC) perspective, the POSD weights in \eqref{DHKM:posdeq} generalize upon the product-and-order dependent (POD) weights in \cite{KuoEtal12a}, which were introduced for analyzing QMC methods in partial differential equations with random coefficients. The latter POD weights can be recovered by ignoring the smoothness weights. 

Our POSD weights differ from the smoothness-driven product-and-order dependent (SPOD) weights in \cite{Dea2014}, which were recently used to analyze higher-order QMC methods for stochastic partial differential equations. These SPOD weights take the form:
\begin{equation*}
\gamma_{\fraku} = \sum_{\bsk \in \{1, \ldots, \alpha\}^{|\fraku|}} \|\bsk\|_1 ! \prod_{\ell \in \fraku} \left( 2^{\delta(k_\ell,\alpha)} w_\ell^{k_\ell} \right), \quad \|\bsk\|_1 = \sum_{\ell=1}^d k_\ell, \quad \fraku \subseteq \{1, \ldots, d\},
%\label{eq:spod}
\end{equation*}
where $\delta (k_\ell,\alpha)$ is 1 if $k_\ell=\alpha$ and 0 otherwise. 
Intuitively, the SPOD weights quantify the importance of each \textit{subspace} (indexed by $\fraku$), under a common smoothness structure among subspaces (for further details on SPOD weights, we refer the reader to \cite{Dea2014}). In contrast, the proposed POSD weights in \eqref{DHKM:posdeq} instead quantify the importance of each \textit{Fourier series coefficient} $\hf(\bsk)$ (indexed by $\bsk$), under a common smoothness structure among coefficients.



\subsection{Inferring POSD Weights from an Initial Sample}

%Let $\calC_{\bslambda}$ denote the cone of inputs defined in \eqref{DHKM:pilot_cone} by POSD weights $\bslambda = \bigl( \lambda_{\bsk} \bigr)_{\bsk \in \N_0^d}$.
As mentioned above, our goal here is to infer $\bslambda$ from input function data.  We start with an initial set of $d k_{\max} + 1$ wavenumbers:
\begin{equation} \label{DHKM:barKdef}
    \bcalK= \{ (0, \ldots, 0, k, 0, \ldots, 0): k = 0, \ldots, k_{\max}\},
\end{equation}
where the possible non-zero entry $k$ may be at any one position in the vector. The approximation to $f$ based on sampling the series coefficients for these wavenumbers is
\begin{equation*}
    \fapp = \sum_{\bsk \in \bar{\calK}} \hf(\bsk) u_{\bsk}.
\end{equation*}
To choose the cone $\calC_{\bslambda,n_1,A}$ which best fits $f$, we select the POSD weights $\bslambda$ to make the norm of $f_{\text{app}}$ small. These weights can be written as:
\begin{multline}
\bar{\bslambda} = \bslambda(\bar{\bsw}, \bar{\bss}, \bsGamma), \\
\text{where } (\bar{\bsw}, \bar{\bss} ) = \min \left\{ \argmin_{(\bsw,\bss) \in \calW \times \calS} \left\|\left( \frac{\hf(\bsk)}{\lambda_{\bsk}(\bsw,\bss,\bsGamma)} \right)_{\bsk \in \bar{\calK}}\right\|_{\rho} \right \}.
\label{DHKM:eq:inf}
\end{multline}
Here, $\calW$ is a candidate set for coordinate weights, e.g., $\calW = [0,w^*]^d$, and $\calS$ is a candidate set for the smoothness weights, e.g., $\calS = \{(1/k^r)_{k=1}^{\infty} \colon r > 0\}$. The inner minimization finds the $(\bsw,\bss)$ that minimizes the approximate norm of the input function.  This minimizer may be non-unique, so the outer minimization chooses the smallest such $(\bsw,\bss)$. Making the coordinate and smoothness weights as small as possible helps enforce the principles of effect sparsity.  The optimum, $(\bar{\bsw}, \bar{\bss})$, then defines the \emph{data-inferred} POSD $\bslambda$, denoted $\bar{\bslambda}$.

The candidate sets $\calW$ and $\calS$ should be constructed such that the coordinate and smoothness weights have a priori upper bounds. Otherwise the inner minimization would choose huge values for $\bsw$ and $\bss$ to maximize the $\lambda_{\bsk}(\bsw,\bss,\bsGamma)$ and minimize the norm of $\fapp$.  The cardinality of the initial set of wavenumbers is $d k_{\max} + 1$.  There is a trade-off between keeping $k_{\max}$ small enough to reduce cost and making $k_{\max}$ large enough to ensure robustness.

For simplicity, we assume that order weights, $\bsGamma$, are fixed a priori.  If desired, they too could be inferred as the next step.  However, since we want to limit the size of the initial sample to $\calO(d)$ we must sample judiciously the higher order interactions.  

The optimization in \eqref{DHKM:eq:inf} is nontrivial to solve numerically. In practice, we iteratively optimize over $\bsw$ and then $\bss$ until convergence is reached.  At each step of the iteration $\|(\hat{f}(\bsk)/\lambda_{\bsk})_{\bsk \in \bcalK}\|_{\rho}$ decreases.

Algorithm \ref{DHKM:InfPilotConeAlg} combines the construction of data-inferred POSD weights, $\bar{\bslambda}$, with Algorithm \ref{DHKM:PilotConeAlg} of Section \ref{DHKM:pilot_sec}. This algorithm succeeds for input functions in the cone 
\begin{equation} \label{DHKM:pilot_cone2}
    \bar{\calC}_{n_1,A} := \left \{ f \in \calF : f \in \calC_{\bar{\bslambda},n_1,A} \text{ for } \bar{\bslambda} \text{ defined in \eqref{DHKM:eq:inf}} \right\}.
\end{equation}
The reason that $\bar{\calC}_{n_1,A}$ is a cone is that the data-inferred $\bar{\bslambda}$ for the input function $f$ is exactly the same as for the input function $cf$, where $c$ is any constant.

\begin{algorithm}
	\caption{Adaptive $\DHKMALG$ Based on Data-Inferred POSD Weights \label{DHKM:InfPilotConeAlg}} 
	\begin{algorithmic}
	\PARAM the bases $\{u_{\bsk}\}_{\bsk \in \N_0^d}$ and $\{v_{\bsk}\}_{\bsk \in \N_0^d}$; candidate sets $\calW$ and $\calS$ for product and smoothness weights; maximum smoothness degree, $k_{\max}$; order weights, $\boldsymbol{\Gamma}$; an inflation factor, $A > 1$; $\DHKMAPP$ satisfying \eqref{DHKM:Refined_APP_err} 
		\INPUT a black-box function, $f$; an absolute error tolerance,
		$\varepsilon>0$

\Ensure Error criterion \eqref{DHKM:err_crit} for the cone defined in \eqref{DHKM:pilot_cone2}
\State  Define the initial set of wavenumbers $\bcalK$ defined in \eqref{DHKM:barKdef}
\State Evaluate initial sample $\bigl\{\hf(\bsk)\bigr\}_{\bsk \in \bcalK}$
\State Compute data-driven POSD weight $\bar{\bslambda}$, by iteratively optimizing over $(\bsw, \bss) \in \calW \times \calS$ in \eqref{DHKM:eq:inf} until convergence
\State Using these weights, $\bar{\bslambda}$, perform Algorithm \ref{DHKM:PilotConeAlg} to obtain $\DHKMALG(f,\varepsilon)$
\RETURN $\DHKMALG(f,\varepsilon)$
\end{algorithmic}
\end{algorithm}

\subsection{Numerical Examples} \label{DHKM:numexamp_sec}

We now investigate the numerical performance of this adaptive algorithm using data-inferred POSD weights. For simplicity, only the case of $\rho = \infty$ and $\rho' = \tau = 1$ is considered in the following examples. Here, the basis functions $(u_\bsk)_{\bsk \in \mathbb{N}_0^d}$ are the Chebyshev polynomials in Section \ref{DHKM:secexamp}, and the solution operator is $\DHKMSOL (f) = f$ (i.e., function approximation). We note that $\|f - \DHKMALG(f,\varepsilon)\|_\infty \le \|f - \DHKMALG(f,\varepsilon)\|_\calG$, so our error criterion \eqref{DHKM:err_crit} implies that $\|f - \DHKMALG(f,\varepsilon)\|_\infty \le \varepsilon$.

The simulation set-up is as follows. The Fourier coefficients for input function $f$, $\{\hat{f}(\bsk)\}_{\bsk \in \mathbb{N}_0^d}$, are randomly sampled as:
\begin{equation*}
\hat{f}(\bsk) = Z_{\bsk} \,  {\Gamma}_{\|\bsk\|_0}^{\rm tr} \prod_{\substack{\ell=1\\ k_\ell>0}}^d {w_\ell^{\rm tr}} {s}_{k_\ell}^{\rm tr}, \quad Z_{\bsk} \overset{i.i.d.}{\sim} \text{Unif}[-1, 1], \quad \bsk \in \mathbb{N}_0^d.
%\label{eq:foursim}
\end{equation*}
Here, $(w_\ell^{\rm tr})_{\ell=1}^d = (1/L^2(\ell))_{\ell=1}^d$, $({\Gamma_m^{\rm tr}})_{m=1}^\infty \equiv 1$ and $(s_k^{\rm tr})_{k=1}^{k_{\rm max}} = (1/k^4)_{k=1}^4$ are the true coordinate, order, and smoothness weights, and $Z_{\bsk}$ randomly sets the magnitude and sign of each coefficient. Moreover, $\bigl(L(\ell)\bigr)_{\ell=1}^d$ is a random permutation of $1, \ldots, d$ to ensure that the order of input variables does not necessarily reflect their order of importance. We also set $\boldsymbol{\Gamma} = \boldsymbol{\Gamma}^{\rm tr}$ in Algorithm \ref{DHKM:InfPilotConeAlg} and use an inflation factor of $A = 1.1$.

Figures \ref{fig:four} (a) and (b) display the total required sample size from Algorithm \ref{DHKM:InfPilotConeAlg}, as a function of the error to tolerance ratio, $\|f - \DHKMALG(f,\varepsilon)\|_\infty/\varepsilon$, in $d=4$ and $d=7$ dimensions, respectively. Each data point corresponds to a different error tolerance $\varepsilon$. A ratio $\|f - \DHKMALG(f,\varepsilon)\|_\infty/\varepsilon$ close to, but not exceeding, one is desired, since this shows that our adaptive algorithm is successful. For $d=4$, $\|f - \DHKMALG(f,\varepsilon)\|_\infty/\varepsilon$ fluctuates around 0.4 for all choices of $\varepsilon$; for $d=7$, this ratio begins at $\DHKMAPProx 0.1$ for $\varepsilon = 0.1$, then decreases to $\DHKMAPProx 0.014$ for $\varepsilon = 0.001$. This shows that our adaptive approximation algorithm works reasonably well.  It appears slightly more effective in lower dimensions  than in higher dimensions. A likely reason is that the underlying POSD structure can be more easily learned from a small pilot sample in lower dimensions than in higher dimensions.


\begin{figure}
\centering
\begin{subfigure}{\textwidth}
\centering
\includegraphics[width=0.7\textwidth]{d4}
\label{fig:four1}
\caption{$f$ is a $d=4$-dim. function with random Fourier coefficients.}
\end{subfigure}
\begin{subfigure}{\textwidth}
\centering
\includegraphics[width=0.7\textwidth]{d7}
\label{fig:four2}
\caption{$f$ is a $d=7$-dim. function with random Fourier coefficients.}
\end{subfigure}
\caption{Total required sample size as a function of error ratio $\|f - \DHKMALG(f,\varepsilon)\|_{\infty}/\varepsilon$, with points colored by the absolute error tolerance level $\varepsilon$.}
\label{fig:four}
\end{figure}

\begin{acknowledgement}
The authors would like to thank two anonymous referees for their suggestions which helped to improve the presentation of the results. Furthermore, the authors thank 
Stefan Heinrich and Aicke Hinrichs for helpful comments.

F.~J.~Hickernell, P.~Kritzer, and S.~Mak gratefully acknowledge the support of the Statistical and Applied Mathematical Sciences Institute year-long ``Program on Quasi-Monte Carlo and High-Dimensional Sampling Methods for Applied Mathematics'' through NSF-DMS-1638521.  F.~J.~Hickernell also acknowledges the support of NSF-DMS-1522687.
F.~J.~Hickernell and P.~Kritzer thank the RICAM Special Semester Program 2018 for support. P.~Kritzer gratefully acknowledges support by the Austrian Science Fund (FWF) Project  F5506-N26, which is part of the Special Research Program ``Quasi-Monte Carlo Methods: Theory and Applications''.
\end{acknowledgement}

\bibliographystyle{spbasic.bst}

\bibliography{ExtraBib.bib,FJH23.bib,FJHown23.bib}

%\section*{Appendix}

\end{document}


